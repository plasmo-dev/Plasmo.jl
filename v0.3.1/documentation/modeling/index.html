<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling · Plasmo.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Plasmo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Plasmo.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Modeling</a><ul class="internal"><li><a class="tocitem" href="#Creating-an-OptiGraph"><span>Creating an OptiGraph</span></a></li><li><a class="tocitem" href="#Adding-OptiNodes"><span>Adding OptiNodes</span></a></li><li><a class="tocitem" href="#Adding-Linking-Constraints-(OptiEdges)"><span>Adding Linking Constraints (OptiEdges)</span></a></li><li><a class="tocitem" href="#Hierarchical-Modeling"><span>Hierarchical Modeling</span></a></li><li><a class="tocitem" href="#Query-OptiGraph-Attributes"><span>Query OptiGraph Attributes</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../partitioning/">Partitioning and Graph Operations</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../../tutorials/tutorials/">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/zavalab/Plasmo.jl/blob/master/docs/src/documentation/modeling.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h1><p>In Plasmo.jl, the primary modeling object is called an <a href="#Plasmo.OptiGraph"><code>OptiGraph</code></a>. The <code>OptiGraph</code> adheres to a graph-based style of modeling that uses nodes and edges to create optimization problems. This graph-based style permits modular model development and makes it possible to capture and represent complex optimization problem structures. An <code>OptiGraph</code> is composed of <a href="#Plasmo.OptiNode"><code>OptiNode</code></a>s which represent individual optimization problems that are connected by <a href="#Plasmo.OptiEdge"><code>OptiEdge</code></a>s which encapsulate <a href="#Plasmo.LinkConstraint"><code>LinkConstraint</code></a>s (i.e. linking constraints that couple optinodes). A key idea behind Plasmo&#39;s&#39; graph-based approach is that it works at a high level of abstraction and uses modular principles and hierarchical modeling to express complex optimization problems. The optimization models created with an optigraph can be used to reveal inherent structures that lend themselves to graph processing tasks such as partitioning.</p><p>The <code>OptiGraph</code> ultimately describes the following mathematical representation of an optimization problem:</p><div>\[\begin{aligned}
    \min_{{\{x_n}\}_{n \in \mathcal{N}(\mathcal{G})}} &amp; \quad \sum_{n \in \mathcal{N(\mathcal{G})}} f_n(x_n) \quad &amp; (\textrm{Objective}) \\
    \textrm{s.t.} &amp; \quad x_n \in \mathcal{X}_n,      \quad n \in \mathcal{N(\mathcal{G})}, \quad &amp; (\textrm{Node Constraints})\\
    &amp; \quad g_e(\{x_n\}_{n \in \mathcal{N}(e)}) = 0,  \quad e \in \mathcal{E(\mathcal{G})}. &amp;(\textrm{Link Constraints})
\end{aligned}\]</div><p>In this formulation, <span>$\mathcal{G}$</span> represents the optigraph, <span>${\{x_n}\}_{n \in \mathcal{N}(\mathcal{G})}$</span> describes a collection of decision variables over the set of nodes (optinodes) <span>$\mathcal{N}(\mathcal{G})$</span>, and <span>$x_n$</span> is the set of decision variables on node <span>$n$</span>. The objective function for the optigraph <span>$\mathcal{G}$</span> is given by a linear combination of objective functions on each optinode <span>$f_n(x_n)$</span>. The second equation represents constraints on each optinode <span>$\mathcal{N}(\mathcal{G})$</span>, and the third equation represents the collection of linking constraints associated with optiedges <span>$\mathcal{E}(\mathcal{G})$</span>. The constraints of an optinode <span>$n$</span> are represented by the set <span>$\mathcal{X}_n$</span> while the linking constraints that correspond to an edge <span>$e$</span> are represented by the vector function <span>$g_e(\{x_n\}_{n \in \mathcal{N}(e)})$</span>.</p><p>From an implementation standpoint, an <code>OptiGraph</code> contains <code>OptiNode</code> and <code>OptiEdge</code> objects and extends much of the modeling functionality and syntax from <a href="https://github.com/jump-dev/JuMP.jl">JuMP</a>. The <code>OptiNode</code> object encapsulates a <code>Model</code> object from <code>JuMP</code>, and the <code>OptiEdge</code> object encapsulates the linking constraints that define coupling between optinodes.</p><h2 id="Creating-an-OptiGraph"><a class="docs-heading-anchor" href="#Creating-an-OptiGraph">Creating an OptiGraph</a><a id="Creating-an-OptiGraph-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-OptiGraph" title="Permalink"></a></h2><p>An <code>OptiGraph</code> does not require any arguments to construct:</p><pre><code class="language-julia-repl">julia&gt; graph1 = OptiGraph()
OptiGraph:
local nodes: 0, total nodes: 0
local link constraints: 0, total link constraints 0
local subgraphs: 0, total subgraphs 0</code></pre><p>An optigraph optimizer can also be specified using <a href="#JuMP.set_optimizer-Tuple{OptiGraph,Any}"><code>JuMP.set_optimizer</code></a> where an optimizer can be any JuMP compatible solver or a custom developed Plasmo.jl solver (see the <a href="../solvers/#Solvers">Solvers</a> section).   For example, we could construct an optigraph that uses the <code>Ipopt.Optimizer</code> from the Ipopt package like following:</p><pre><code class="language-julia">julia&gt; using Ipopt

julia&gt; set_optimizer(graph1,Ipopt.Optimizer)</code></pre><h2 id="Adding-OptiNodes"><a class="docs-heading-anchor" href="#Adding-OptiNodes">Adding OptiNodes</a><a id="Adding-OptiNodes-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-OptiNodes" title="Permalink"></a></h2><p>The most effective way to add optinodes to an optigraph is by using the <a href="#Plasmo.@optinode"><code>@optinode</code></a> macro.  The below piece of code adds the node <code>n1</code> to the optigraph <code>graph1</code>.</p><pre><code class="language-julia-repl">julia&gt; @optinode(graph1,n1)
OptiNode w/ 0 Variable(s)</code></pre><p>It is also possible to create sets of optinodes with a single call to <a href="#Plasmo.@optinode"><code>@optinode</code></a> like shown in the below code snippet. Here, we create two more optinodes which returns the reference <code>nodes</code>. This input produces a <code>JuMP.DenseAxisArray</code> which allows us to refer to each optinode using the produced index sets.  For example, <code>nodes[2]</code> and <code>nodes[3]</code> each return the corresponding optinode.</p><pre><code class="language-julia-repl">julia&gt; @optinode(graph1,nodes[2:3])
1-dimensional DenseAxisArray{OptiNode,1,...} with index sets:
    Dimension 1, 2:3
And data, a 2-element Array{OptiNode,1}:
 OptiNode w/ 0 Variable(s)
 OptiNode w/ 0 Variable(s)

julia&gt; nodes[2]
OptiNode w/ 0 Variable(s)

julia&gt; nodes[3]
OptiNode w/ 0 Variable(s)</code></pre><p>Each optinode can have its underlying model constructed in a modular way.  Here we loop through each optinode in <code>graph1</code> using <a href="#Plasmo.getnodes"><code>getnodes</code></a> and construct its underlying model by adding variables, a constraint, and objective function.</p><pre><code class="language-julia-repl">julia&gt;  for node in getnodes(graph1)
            @variable(node,x &gt;= 0)
            @variable(node, y &gt;= 2)
            @constraint(node,x + y &gt;= 3)
            @objective(node, Min, y)
        end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <a href="#Plasmo.OptiNode"><code>OptiNode</code></a> extends <code>JuMP.AbstractModel</code> and supports most of the same JuMP macros. However, extending nonlinear functionality in JuMP is not yet supported, and so  one must use <a href="#Plasmo.@NLnodeconstraint"><code>@NLnodeconstraint</code></a> as opposed <code>@NLconstraint</code> to create nonlinear constraints on an optinode.</p></div></div><p>Variables within an optinode can be accessed directly by indexing the associated symbol.  This enclosed variable space is useful for referencing variables on different optinodes when creating linking constraints or optigraph objective functions.</p><pre><code class="language-julia-repl">julia&gt; n1[:x]
x

julia&gt; nodes[2][:y]
y</code></pre><h2 id="Adding-Linking-Constraints-(OptiEdges)"><a class="docs-heading-anchor" href="#Adding-Linking-Constraints-(OptiEdges)">Adding Linking Constraints (OptiEdges)</a><a id="Adding-Linking-Constraints-(OptiEdges)-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Linking-Constraints-(OptiEdges)" title="Permalink"></a></h2><p>Linking constraints (<a href="#Plasmo.LinkConstraint"><code>LinkConstraint</code></a>s) are linear constraints that couple variables across different optinodes.  The simplest way to create a linking constraint is to use the <code>@linkconstraint</code> macro.  This macro accepts the same input as the JuMP <code>@constraint</code> macro and creates linear constraints over multiple nodes within the same optigraph.</p><pre><code class="language-julia-repl">julia&gt; @linkconstraint(graph1, n1[:x] + nodes[2][:x] + nodes[3][:x] == 3)
LinkConstraintRef(1, OptiEdge w/ 1 Constraint(s))</code></pre><p>We can also plot the graph structure of <code>graph1</code> (see <a href="../plotting/#Plotting">Plotting</a>) using both a graph and matrix layouts.</p><pre><code class="language-julia-repl">julia&gt; using Plots;

julia&gt; plt_graph = Plots.plot(graph1,node_labels = true, markersize = 30,labelsize = 15, linewidth = 4,layout_options = Dict(:tol =&gt; 0.01,:iterations =&gt; 2),plt_options = Dict(:legend =&gt; false,:framestyle =&gt; :box,:grid =&gt; false,:size =&gt; (400,400),:axis =&gt; nothing));

julia&gt; Plots.savefig(plt_graph,&quot;graph1_layout.svg&quot;);

julia&gt; plt_matrix = Plots.spy(graph1,node_labels = true,markersize = 15);

julia&gt; Plots.savefig(plt_matrix,&quot;matrix1_layout.svg&quot;);</code></pre><img src="../graph1_layout.svg" alt="graph1" width="400"/><img src="../matrix1_layout.svg" alt="matrix1" width="400"/><h2 id="Hierarchical-Modeling"><a class="docs-heading-anchor" href="#Hierarchical-Modeling">Hierarchical Modeling</a><a id="Hierarchical-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchical-Modeling" title="Permalink"></a></h2><p>A fundamental feature of using optigraphs is that it is possible to create subgraphs (i.e. sub-optigraphs) within an optigraph.  This enables a hierarchical style of modeling that retains its modular aspects. Subgraphs are defined using the <a href="#Plasmo.add_subgraph!"><code>add_subgraph!</code></a> function which embeds an optigraph as a subgraph within a higher level optigraph. This is demonstrated in the below snippets.  </p><p>First, we create two new optigraphs in the same fashion we did above.</p><pre><code class="language-julia-repl">julia&gt; graph2 = OptiGraph();

julia&gt; @optinode(graph2,nodes2[1:3]);

julia&gt;  for node in getnodes(graph2)
            @variable(node, x &gt;= 0)
            @variable(node, y &gt;= 2)
            @constraint(node,x + y &gt;= 5)
            @objective(node, Min, y)
        end

julia&gt; @linkconstraint(graph2, nodes2[1][:x] + nodes2[2][:x] + nodes2[3][:x] == 5);

julia&gt; graph3 = OptiGraph();

julia&gt; @optinode(graph3,nodes3[1:3]);

julia&gt;  for node in getnodes(graph3)
            @variable(node, x &gt;= 0)
            @variable(node, y &gt;= 2)
            @constraint(node,x + y &gt;= 5)
            @objective(node, Min, y)
        end

julia&gt; @linkconstraint(graph3, nodes3[1][:x] + nodes3[2][:x] + nodes3[3][:x] == 7);</code></pre><p>Now we have three optigraphs (<code>graph1</code>,<code>graph2</code>, and <code>graph3</code>), each with their own local optinodes and linking constraints (which induce optiedges).   These optigraphs can be embedded into a higher level optigraph with the following snippet:</p><pre><code class="language-julia-repl">julia&gt; graph0 = OptiGraph()
OptiGraph:
local nodes: 0, total nodes: 0
local link constraints: 0, total link constraints 0
local subgraphs: 0, total subgraphs 0

julia&gt; add_subgraph!(graph0,graph1)
OptiGraph:
local nodes: 0, total nodes: 3
local link constraints: 0, total link constraints 1
local subgraphs: 1, total subgraphs 1

julia&gt; add_subgraph!(graph0,graph2)
OptiGraph:
local nodes: 0, total nodes: 6
local link constraints: 0, total link constraints 2
local subgraphs: 2, total subgraphs 2

julia&gt; add_subgraph!(graph0,graph3)
OptiGraph:
local nodes: 0, total nodes: 9
local link constraints: 0, total link constraints 3
local subgraphs: 3, total subgraphs 3</code></pre><p>Here, we see the distinction between local and global (total) elements. For instance, after we add all three subgraphs the higher level <code>graph0</code>, we see that <code>graph0</code> contains 0 local optinodes, but contains 9 total optinodes which are elements of its subgraphs. This hierarchical distinction is also made for linking constraints (i.e. optiedges), as well as subgraphs.  With this hierarhical style of modeling, subgraphs can be nested recursively such that an optigraph might contain local subgraphs, and the highest level optigraph contains all of the subgraphs.</p><p>A key benefit of this hierarchical approach is that linking constraints can be expressed both locally and globally.  For instance, we can now add a linking constraint to <code>graph0</code> that connects optinodes in its subgraphs like following:</p><pre><code class="language-julia-repl">julia&gt; @linkconstraint(graph0,nodes[3][:x] + nodes2[2][:x] + nodes3[1][:x] == 10)
LinkConstraintRef(1, OptiEdge w/ 1 Constraint(s))

julia&gt; println(graph0)
OptiGraph:
local nodes: 0, total nodes: 9
local link constraints: 1, total link constraints 4
local subgraphs: 3, total subgraphs 3</code></pre><p>We now observe that <code>graph0</code> contains 1 local linking constraint, and 4 total linking constraints (by including its subgraphs). Put another way, the local linking constraint in <code>graph0</code> is a global constraint that connects each of its subgraphs. This hierarchical style of modeling facilitates the construction of optimization problems that include diverse model components.  For instance, a power system could be modeled separately from a natural gas system and they could be coupled in a higher level combined optigraph.  The hierarchical structure also enables the use of distributed optimization solvers which we discuss more in the <a href="../solvers/#Solvers">Solvers</a> section.</p><p>We can lastly plot the hierarchical optigraph and see the nested subgraph structure.</p><pre><code class="language-julia-repl">julia&gt; using Plots

julia&gt; for (i,node) in enumerate(all_nodes(graph0))
           node.label = &quot;n$i&quot;
       end

julia&gt; plt_graph0 = Plots.plot(graph0,node_labels = true,markersize = 60,labelsize = 30,linewidth = 4,subgraph_colors = true,
       layout_options = Dict(:tol =&gt; 0.001,:C =&gt; 2, :K =&gt; 4, :iterations =&gt; 5));

julia&gt; Plots.savefig(plt_graph0,&quot;graph0_layout.svg&quot;);

julia&gt; plt_matrix0 = Plots.spy(graph0,node_labels = true,subgraph_colors = true,markersize = 16);

julia&gt; Plots.savefig(plt_matrix0,&quot;matrix0_layout.svg&quot;);</code></pre><img src="../graph0_layout.svg" alt="graph0" width="400"/><img src="../matrix0_layout.svg" alt="matrix0" width="400"/><h2 id="Query-OptiGraph-Attributes"><a class="docs-heading-anchor" href="#Query-OptiGraph-Attributes">Query OptiGraph Attributes</a><a id="Query-OptiGraph-Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Query-OptiGraph-Attributes" title="Permalink"></a></h2><p>There are a few primary function which can be used to query optigraph attributes. <code>getnodes</code> can be used to retrieve an array of the local optinodes in an optigraph, whereas <code>all_nodes</code> will recursively retrieve all of the optinodes in an optigraph, including the nodes in its subgraphs.</p><pre><code class="language-julia-repl">julia&gt; getnodes(graph1)
3-element Array{OptiNode,1}:
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)

julia&gt; getnodes(graph0)
0-element Array{OptiNode,1}

julia&gt; all_nodes(graph0)
9-element Array{OptiNode,1}:
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
 OptiNode w/ 2 Variable(s)
</code></pre><p>It is possible to query for optiedges, linking constraints, and subgraphs in the same way. We can query optiedges:</p><pre><code class="language-julia-repl">julia&gt; getedges(graph1)
1-element Array{OptiEdge,1}:
 OptiEdge w/ 1 Constraint(s)

julia&gt; getedges(graph0)
1-element Array{OptiEdge,1}:
 OptiEdge w/ 1 Constraint(s)

julia&gt; all_edges(graph0)
4-element Array{OptiEdge,1}:
 OptiEdge w/ 1 Constraint(s)
 OptiEdge w/ 1 Constraint(s)
 OptiEdge w/ 1 Constraint(s)
 OptiEdge w/ 1 Constraint(s)</code></pre><p>query linking constraints:</p><pre><code class="language-julia-repl">julia&gt; getlinkconstraints(graph1)
1-element Array{LinkConstraint,1}:
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(3.0)

julia&gt; getlinkconstraints(graph0)
1-element Array{LinkConstraint,1}:
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(10.0)

julia&gt; all_linkconstraints(graph0)
4-element Array{LinkConstraint,1}:
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(3.0)
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(5.0)
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(7.0)
 LinkConstraint: x + x + x, MathOptInterface.EqualTo{Float64}(10.0)</code></pre><p>and query subgraphs:</p><pre><code class="language-julia-repl">julia&gt; getsubgraphs(graph0)
3-element Array{AbstractOptiGraph,1}:
 OptiGraph:
local nodes: 3, total nodes: 3
local link constraints: 1, total link constraints 1
local subgraphs: 0, total subgraphs 0

 OptiGraph:
local nodes: 3, total nodes: 3
local link constraints: 1, total link constraints 1
local subgraphs: 0, total subgraphs 0

 OptiGraph:
local nodes: 3, total nodes: 3
local link constraints: 1, total link constraints 1
local subgraphs: 0, total subgraphs 0</code></pre><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><p>Modeling with an <code>OptiGraph</code> encompasses various useful methods.  It is important to note that both the <code>OptiGraph</code> and the <code>OptiNode</code> are extensions of the <code>JuMP.AbstractModel</code> and can use many of the same methods. We refer to the <a href="https://jump.dev/JuMP.jl/stable/">JuMP Documentation</a> which describes most methods. Some select functions are also listed here.</p><h3 id="OptiGraph-Functions"><a class="docs-heading-anchor" href="#OptiGraph-Functions">OptiGraph Functions</a><a id="OptiGraph-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#OptiGraph-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Plasmo.OptiGraph" href="#Plasmo.OptiGraph"><code>Plasmo.OptiGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptiGraph()</code></pre><p>Create an empty OptiGraph. An OptiGraph extends JuMP.AbstractModel and supports many JuMP.Model functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.@optinode" href="#Plasmo.@optinode"><code>Plasmo.@optinode</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@optinode(optigraph, expr...)</code></pre><p>Add a new optinode to <code>optigraph</code>. The expression <code>expr</code> can either be</p><ul><li>of the form <code>varname</code> creating a single optinode with the variable name <code>varname</code></li><li>of the form <code>varname[...]</code> or <code>[...]</code> creating a container of optinodes using JuMP Containers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/macros.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.OptiNode" href="#Plasmo.OptiNode"><code>Plasmo.OptiNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptiNode()</code></pre><p>Creates an empty OptiNode.  Does not add it to a graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optinode.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.add_node!" href="#Plasmo.add_node!"><code>Plasmo.add_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_node!(graph::OptiGraph)</code></pre><p>Create a new <code>OptiNode</code> and add it to <code>graph</code>. Returns the added optinode.</p><pre><code class="language-none">add_node!(graph::OptiGraph,m::JuMP.Model)</code></pre><p>Add a new optinode to <code>graph</code> and set its model to the <code>JuMP.Model</code> <code>m</code>.</p><pre><code class="language-none">add_node!(graph::OptiGraph,optinode::OptiNode)</code></pre><p>Add the existing <code>optinode</code> (Created with <code>OptiNode()</code>) to <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L95-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getnode" href="#Plasmo.getnode"><code>Plasmo.getnode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getnode(graph::OptiGraph) = graph.optinodes</code></pre><p>Retrieve the local optinode in <code>graph</code> at <code>index</code>. This does not look up nodes that could be in subgraphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getnodes" href="#Plasmo.getnodes"><code>Plasmo.getnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getnodes(graph::OptiGraph) = graph.optinodes</code></pre><p>Retrieve the optinodes in <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.find_node" href="#Plasmo.find_node"><code>Plasmo.find_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_node(graph::OptiGraph,index::Int64)</code></pre><p>Find the optinode in <code>graph</code> at <code>index</code>. This traverses all of the nodes in the subgraphs of <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.is_node_variable" href="#Plasmo.is_node_variable"><code>Plasmo.is_node_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_node_variable(node::OptiNode,var::JuMP.AbstractVariableRef)</code></pre><p>Checks whether the variable <code>var</code> belongs to the optinode <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optinode.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{OptiGraph,OptiNode}" href="#Base.getindex-Tuple{OptiGraph,OptiNode}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(graph::OptiGraph,node::OptiNode)</code></pre><p>Retrieve the index of the optinode <code>node</code> in <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{OptiGraph,OptiEdge}" href="#Base.getindex-Tuple{OptiGraph,OptiEdge}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(graph::OptiGraph,optiedge::OptiEdge)</code></pre><p>Retrieve the index of the <code>optiedge</code> in <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.nodevalue" href="#Plasmo.nodevalue"><code>Plasmo.nodevalue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nodevalue(var::JuMP.VariableRef)</code></pre><p>Get the current value of <code>var</code></p><pre><code class="language-none">nodevalue(expr::JuMP.GenericAffExpr)</code></pre><p>Get the current value of <code>expr</code> which is <code>JuMP.GenericAffExpr</code></p><pre><code class="language-none">nodevalue(expr::JuMP.GenericQuadExpr)</code></pre><p>Get the current value of <code>expr</code> which is a <code>JuMP.GenericQuadExpr</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optinode.jl#L70-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.all_nodes" href="#Plasmo.all_nodes"><code>Plasmo.all_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_nodes(graph::OptiGraph)</code></pre><p>Recursively collect nodes in a optigraph from each of its subgraphs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.set_model" href="#Plasmo.set_model"><code>Plasmo.set_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_model(node::OptiNode,m::AbstractModel)</code></pre><p>Set the model on a node.  This will delete any link-constraints the node is currently part of</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optinode.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.@NLnodeconstraint" href="#Plasmo.@NLnodeconstraint"><code>Plasmo.@NLnodeconstraint</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@NLnodeconstraint(node,args...)</code></pre><p>Add a nonlinear constraint to an optinode.  Wraps JuMP.@NLconstraint.  This method will deprecate once optinodes extend nonlinear JuMP functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/macros.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.@linkconstraint" href="#Plasmo.@linkconstraint"><code>Plasmo.@linkconstraint</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@linkconstraint(graph::OptiGraph, expr)</code></pre><p>Add a linking constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@linkconstraint(graph::OptiGraph, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of linking  constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The @linkconstraint macro works the same way as the <code>JuMP.@constraint</code> macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/macros.jl#L67-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.OptiEdge" href="#Plasmo.OptiEdge"><code>Plasmo.OptiEdge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptiEdge</code></pre><p>The <code>OptiEdge</code> type.  Typically created from <a href="#Plasmo.@linkconstraint"><code>@linkconstraint</code></a>.  Contains the set of its supporting optionodes, as well as references to its underlying linking constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optiedge.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getedge" href="#Plasmo.getedge"><code>Plasmo.getedge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getedge(graph::OptiGraph,index::Int64)</code></pre><p>Retrieve the local optiedge in <code>graph</code> at <code>index</code></p><pre><code class="language-none">getedge(graph::OptiGraph,nodes::OrderedSet{OptiNode})</code></pre><p>Retrieve the optiedge in <code>graph</code> that connects the optinodes in the OrderedSet of <code>nodes</code>.</p><pre><code class="language-none">getedge(graph::OptiGraph,nodes::OptiNode...)</code></pre><p>Retrieve the optiedge in <code>graph</code> that connects <code>nodes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L202-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getedges" href="#Plasmo.getedges"><code>Plasmo.getedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getedges(graph::OptiGraph) = graph.optiedges</code></pre><p>Retrieve the local optiedges in <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.all_edges" href="#Plasmo.all_edges"><code>Plasmo.all_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_edges(graph::OptiGraph)</code></pre><p>Retrieve all optiedges in <code>graph</code>, includes edges in subgraphs of <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.LinkConstraint" href="#Plasmo.LinkConstraint"><code>Plasmo.LinkConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinkConstraint{F &lt;: JuMP.AbstractJuMPScalar,S &lt;: MOI.AbstractScalarSet} &lt;: AbstractLinkConstraint</code></pre><p>Type inherits JuMP.AbstractConstraint.  Contains a func and set used to describe coupling between optinodes.</p><pre><code class="language-none">LinkConstraint(con::JuMP.ScalarConstraint)</code></pre><p>Creates a linking constraint from a JuMP.ScalarConstraint.</p><pre><code class="language-none">LinkConstraint(ref::LinkConstraintRef)</code></pre><p>Retrieves a linking constraint from a LinkConstraintRef.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optiedge.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getlinkconstraints" href="#Plasmo.getlinkconstraints"><code>Plasmo.getlinkconstraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getlinkconstraints(graph::OptiGraph)::Vector{LinkConstraint}</code></pre><p>Retrieve the local linking constraints in <code>graph</code>. Returns a vector of the linking constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.all_linkconstraints" href="#Plasmo.all_linkconstraints"><code>Plasmo.all_linkconstraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_linkconstraints(graph::OptiGraph)::Vector{LinkConstraint}</code></pre><p>Retrieve all of the linking constraints in <code>graph</code>, including linking constraints in its subgraphs. Returns a vector of the linking constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.add_subgraph!" href="#Plasmo.add_subgraph!"><code>Plasmo.add_subgraph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_subgraph!(graph::OptiGraph,subgraph::OptiGraph)</code></pre><p>Add the sub-optigraph <code>subgraph</code> to the higher level optigraph <code>graph</code>. Returns the original <code>graph</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.getsubgraphs" href="#Plasmo.getsubgraphs"><code>Plasmo.getsubgraphs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getsubgraphs(optigraph::OptiGraph)::Vector{OptiGraph}</code></pre><p>Retrieve the local subgraphs of <code>optigraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.all_subgraphs" href="#Plasmo.all_subgraphs"><code>Plasmo.all_subgraphs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_subgraphs(optigraph::OptiGraph)::Vector{OptiGraph}</code></pre><p>Retrieve all of the contained subgraphs of <code>optigraph</code>, including nested subgraphs. The order of the subgraphs in the returned vector starts with the local subgraphs in <code>optigraph</code> and then appends the nested subgraphs for each local subgraph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L79-L84">source</a></section></article><h3 id="Extended-JuMP-Functions"><a class="docs-heading-anchor" href="#Extended-JuMP-Functions">Extended JuMP Functions</a><a id="Extended-JuMP-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-JuMP-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_variables-Tuple{OptiNode}" href="#JuMP.all_variables-Tuple{OptiNode}"><code>JuMP.all_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.all_variables(node::OptiNode)::Vector{JuMP.VariableRef}</code></pre><p>Retrieve all of the variables on the optinode <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optinode.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_optimizer-Tuple{OptiGraph,Any}" href="#JuMP.set_optimizer-Tuple{OptiGraph,Any}"><code>JuMP.set_optimizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_optimizer(graph::OptiGraph,optimizer::Any)</code></pre><p>Set an optimizer for the optigraph <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L559-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_function-Tuple{OptiGraph}" href="#JuMP.objective_function-Tuple{OptiGraph}"><code>JuMP.objective_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.objective_function(graph::OptiGraph)</code></pre><p>Retrieve the current graph objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L336-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{OptiNode,VariableRef}" href="#JuMP.value-Tuple{OptiNode,VariableRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(node::OptiNode,vref::VariableRef)</code></pre><p>Get the variable value of <code>vref</code> on the optinode <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optinode.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_variables-Tuple{OptiGraph}" href="#JuMP.num_variables-Tuple{OptiGraph}"><code>JuMP.num_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_variables(graph::OptiGraph)</code></pre><p>Retrieve the number of local node variables in <code>graph</code>. Does not include variables in subgraphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L312-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_constraints-Tuple{OptiGraph}" href="#JuMP.num_constraints-Tuple{OptiGraph}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_constraints(graph::OptiGraph)</code></pre><p>Retrieve the number of local node constraints in <code>graph</code>. Does not include constraints in subgraphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/729081e9fb6da053f0b18e56493c81f50206b968/src/optigraph.jl#L322-L326">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><a class="docs-footer-nextpage" href="../partitioning/">Partitioning and Graph Operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 17 September 2020 02:51">Thursday 17 September 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
