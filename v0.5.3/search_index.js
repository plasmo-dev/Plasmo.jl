var documenterSearchIndex = {"docs":
[{"location":"documentation/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"Plasmo.jl is intended to support MathOptInterface.jl solvers in the same way as JuMP.","category":"page"},{"location":"documentation/solvers/#MathOptInterface.jl-Solvers","page":"Solvers","title":"MathOptInterface.jl Solvers","text":"","category":"section"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"Solvers with MathOptInterface.jl wrappers should be accessible to Plasmo.jl using standard JuMP functions (i.e. the set_optimizer and optimize! functions should work for an OptiGraph just like they do for a JuMP.Model) The list of available JuMP solvers is extensive and can be found on the JuMP documentation page.","category":"page"},{"location":"documentation/solvers/#Plasmo.jl-Solvers","page":"Solvers","title":"Plasmo.jl Solvers","text":"","category":"section"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"Specialized Plasmo.jl solvers are not yet supported, although this will change in the future as we define a standard solver interface. Please stay tuned for custom Plasmo.jl solver releases and updates.","category":"page"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"<!– ### MadNLP MadNLP is an NLP solver that can solve OptiGraphs directly using parallel function evaluations and specialized decomposition schemes.","category":"page"},{"location":"documentation/solvers/#PipsNLP.jl","page":"Solvers","title":"PipsNLP.jl","text":"","category":"section"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"The PipsNLP interface can be used to solve structured nonlinear optimization problems with PIPS-NLP using MPI.  The examples folder in PipsNLP.jl shows how to use the Julia MPIManager as part of MPIClusterManagers to model and optimize optigraphs in a distributed fashion. Note however, that it requires building an old commit specified on the PipsNLP.jl README.   ","category":"page"},{"location":"documentation/solvers/#SchwarzOpt.jl","page":"Solvers","title":"SchwarzOpt.jl","text":"","category":"section"},{"location":"documentation/solvers/","page":"Solvers","title":"Solvers","text":"The SchwarzOpt optimizer is currently an experimental solver. It demonstrates how to use graph overlap to solve optigraphs with Schwarz decomposition. –>","category":"page"},{"location":"documentation/modeling/#Modeling-with-OptiGraphs","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"The primary modeling object in Plasmo.jl is the OptiGraph. An optigraph is composed of OptiNodes (which represent self-contained optimization problems) which are connected by OptiEdges (which encapsulate LinkConstraints that couple optinodes). The optigraph provides a modular approach to create optimization problems and provides graph functions which can be used to manage model development, reveal inherent structures, and perform graph processing tasks such as partitioning.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"The optigraph ultimately describes the following mathematical representation of an optimization problem:","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"beginaligned\n    min_x_n_n in mathcalN(mathcalG)  quad sum_n in mathcalN(mathcalG) f_n(x_n) quad  (textrmObjective) \n    textrmst  quad x_n in mathcalX_n      quad n in mathcalN(mathcalG) quad  (textrmNode Constraints)\n     quad g_e(x_n_n in mathcalN(e)) = 0  quad e in mathcalE(mathcalG) (textrmLink Constraints)\nendaligned","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"In this formulation, mathcalG represents the optigraph, x_n_n in mathcalN(mathcalG) describes a collection of decision variables over the set of nodes (optinodes) mathcalN(mathcalG), and x_n is the set of decision variables on node n. The objective function for the optigraph mathcalG is given by a linear combination of objective functions on each optinode f_n(x_n). The second equation represents constraints on each optinode mathcalN(mathcalG), and the third equation represents the collection of linking constraints associated with optiedges mathcalE(mathcalG). The constraints of an optinode n are represented by the set mathcalX_n while the linking constraints that correspond to an edge e are represented by the vector function g_e(x_n_n in mathcalN(e)).","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"From an implementation standpoint, an optigraph contains optinode and optiedge objects and extends much of the modeling functionality and syntax from JuMP.","category":"page"},{"location":"documentation/modeling/#Creating-an-OptiGraph","page":"Modeling with OptiGraphs","title":"Creating an OptiGraph","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"An optigraph does not require any arguments to construct:","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"CurrentModule = Plasmo\nDocTestSetup = quote\n    using Plasmo\nend","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> using Plasmo\n\njulia> graph1 = OptiGraph()\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     0              (0)\n      OptiEdges:     0              (0)\nLinkConstraints:     0              (0)\n sub-OptiGraphs:     0              (0)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"DocTestSetup = nothing","category":"page"},{"location":"documentation/modeling/#Adding-OptiNodes","page":"Modeling with OptiGraphs","title":"Adding OptiNodes","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"The most effective way to add optinodes to an optigraph is by using the @optinode macro.  The below snippet adds the node n1 to the optigraph graph1.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> @optinode(graph1,n1)\nOptiNode w/ 0 Variable(s) and 0 Constraint(s)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"It is also possible to create sets of optinodes with a single call to @optinode like shown in the below code snippet. Here, we create two more optinodes which returns the reference nodes. This macro call produces a JuMP.DenseAxisArray which allows us to refer to each optinode using the produced index sets.  For example, nodes[2] and nodes[3] each return the corresponding optinode.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> @optinode(graph1,nodes[2:3])\n1-dimensional DenseAxisArray{OptiNode,1,...} with index sets:\n    Dimension 1, 2:3\nAnd data, a 2-element Vector{OptiNode}:\n OptiNode w/ 0 Variable(s) and 0 Constraint(s)\n OptiNode w/ 0 Variable(s) and 0 Constraint(s)\n\njulia> nodes[2]\nOptiNode w/ 0 Variable(s) and 0 Constraint(s)\n\njulia> nodes[3]\nOptiNode w/ 0 Variable(s) and 0 Constraint(s)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"Each optinode supports adding variables, constraints, and an objective function. Here we loop through each optinode in graph1 using the optinodes function and we construct underlying model elements.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia>  for node in optinodes(graph1)\n            @variable(node,x >= 0)\n            @variable(node, y >= 2)\n            @constraint(node, conref, x + y >= 3)\n            @NLconstraint(node, nlconref, x^3 >= 1)\n            @objective(node, Min, x + y)\n        end","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"note: Note\nThe OptiNode extends a JuMP.AbstractModel and supports JuMP macros such as @variable, @constraint, @NLconstraint, and @objective","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"Variables within an optinode can be accessed directly by indexing the associated symbol. This enclosed name-space is useful for referencing variables on different optinodes when creating link-constraints or optigraph objective functions.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> n1[:x]\nn1[:x]\n\njulia> nodes[2][:x]\nnodes[2][:x]","category":"page"},{"location":"documentation/modeling/#Adding-LinkConstraints","page":"Modeling with OptiGraphs","title":"Adding LinkConstraints","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"LinkConstraints are linear constraints that couple variables across optinodes. The simplest way to create a link-constraint is to use the @linkconstraint macro. This macro accepts the same input as the @constraint macro, but it requires variables to be on at least two different optinodes.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> @linkconstraint(graph1, linkconref, n1[:x] + nodes[2][:x] + nodes[3][:x] == 3)\nlinkconref: n1[:x] + nodes[2][:x] + nodes[3][:x] = 3.0","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"note: Note\nNonlinear link-constraints are not yet supported.","category":"page"},{"location":"documentation/modeling/#Solving-and-Querying-Solutions","page":"Modeling with OptiGraphs","title":"Solving and Querying Solutions","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"An optimizer can be specified using the set_optimizer function which supports any MathOptInterface.jl optimizer. For example, we could use the Ipopt.Optimizer from the Ipopt.jl package and solve the optigraph as following:","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> using Ipopt\n\njulia> set_optimizer(graph1, Ipopt.Optimizer)\n\njulia> set_optimizer_attribute(graph1, \"print_level\", 0) #suppress Ipopt output\n\njulia> optimize!(graph1)\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"The solution of an optigraph is stored directly on its optinodes and optiedges. Variables values, constraint duals, objective function values, and solution status codes can be queried just like in JuMP.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> termination_status(graph1)   \nLOCALLY_SOLVED::TerminationStatusCode = 4\n\njulia> value(n1[:x])    \n1.0\n\njulia> value(nodes[2][:x])\n1.0\n\njulia> value(nodes[3][:x])\n1.0\n\njulia> round(objective_value(graph1))\n9.0\n\njulia> round(dual(linkconref), digits = 2)\n-0.25\n\njulia> round(dual(n1[:conref]), digits = 2)\n0.5\n\njulia> round(dual(n1[:nlconref]), digits = 2)\n0.25","category":"page"},{"location":"documentation/modeling/#Plotting-OptiGraphs","page":"Modeling with OptiGraphs","title":"Plotting OptiGraphs","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"We can also plot the graph structure of graph1 using both graph and matrix layouts from the PlasmoPlots package.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"    using Plasmo\n    graph1 = OptiGraph()\n    @optinode(graph1,n1)\n    @optinode(graph1,nodes[2:3])\n\n    for node in optinodes(graph1)\n        @variable(node,x >= 0)\n        @variable(node, y >= 2)\n        @constraint(node,x + y >= 3)\n        @objective(node, Min, y)\n    end\n\n    @linkconstraint(graph1, n1[:x] + nodes[2][:x] + nodes[3][:x] == 3)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"using PlasmoPlots\n\nplt_graph = layout_plot(graph1,\n                        node_labels=true,\n                        markersize=30,\n                        labelsize=15,\n                        linewidth=4,\n                        layout_options=Dict(:tol=>0.01,\n                                            :iterations=>2),\n                        plt_options=Dict(:legend=>false,\n                                         :framestyle=>:box,\n                                         :grid=>false,\n                                         :size=>(400,400),\n                                         :axis => nothing))\n\nplt_matrix = matrix_layout(graph1, node_labels=true, markersize=15);   ","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"(Image: graph_modeling1) (Image: matrix_modeling1)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"note: Note\nThe layout_plot and matrix_plot functions return a Plots.plot object which can be used for further customization and saving using Plots.jl","category":"page"},{"location":"documentation/modeling/#Hierarchical-Modeling-using-Subgraphs","page":"Modeling with OptiGraphs","title":"Hierarchical Modeling using Subgraphs","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"Another fundamental feature of an optigraph is the ability to create subgraphs (i.e. sub-optigraphs). Subgraphs are defined using the add_subgraph! function which embeds an optigraph as a subgraph within a higher level optigraph. This is demonstrated in the below snippets. First, we create two new optigraphs in the same fashion we did above.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> graph2 = OptiGraph();\n\njulia> @optinode(graph2,nodes2[1:3]);\n\njulia>  for node in optinodes(graph2)\n            @variable(node, x >= 0)\n            @variable(node, y >= 2)\n            @constraint(node,x + y >= 5)\n            @objective(node, Min, y)\n        end\n\njulia> @linkconstraint(graph2, nodes2[1][:x] + nodes2[2][:x] + nodes2[3][:x] == 5);\n\njulia> graph3 = OptiGraph();\n\njulia> @optinode(graph3,nodes3[1:3]);\n\njulia>  for node in optinodes(graph3)\n            @variable(node, x >= 0)\n            @variable(node, y >= 2)\n            @constraint(node,x + y >= 5)\n            @objective(node, Min, y)\n        end\n\njulia> @linkconstraint(graph3, nodes3[1][:x] + nodes3[2][:x] + nodes3[3][:x] == 7);","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"We now have three optigraphs (graph1,graph2, and graph3), each with their own local optinodes and optiedges (link-constraints).   These optigraphs can be embedded into a higher level optigraph with the following snippet:","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> graph0 = OptiGraph()\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     0              (0)\n      OptiEdges:     0              (0)\nLinkConstraints:     0              (0)\n sub-OptiGraphs:     0              (0)\n\njulia> add_subgraph!(graph0,graph1)\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     0              (3)\n      OptiEdges:     0              (1)\nLinkConstraints:     0              (1)\n sub-OptiGraphs:     1              (1)\n\njulia> add_subgraph!(graph0,graph2)\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     0              (6)\n      OptiEdges:     0              (2)\nLinkConstraints:     0              (2)\n sub-OptiGraphs:     2              (2)\n\njulia> add_subgraph!(graph0,graph3)\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     0              (9)\n      OptiEdges:     0              (3)\nLinkConstraints:     0              (3)\n sub-OptiGraphs:     3              (3)\n","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"Here, we see the distinction between local and  total elements. After we add all three subgraphs to graph0, we see that it contains 0 local optinodes, but contains 9 total optinodes which are elements of its subgraphs. This hierarchical distinction is also made for optiedges (link-constraints) and additional subgraphs. Subgraphs can be nested recursively such that an optigraph might contain local subgraphs, and the highest level optigraph contains all of the subgraphs.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"Using this hierarchical approach, link-constraints can be expressed both locally and globally. For instance, we can add a link-constraint to graph0 that connects optinodes across its subgraphs like following:","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> @linkconstraint(graph0,nodes[3][:x] + nodes2[2][:x] + nodes3[1][:x] == 10)\n: nodes[3][:x] + nodes2[2][:x] + nodes3[1][:x] = 10.0\n\njulia> println(graph0)\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     0              (9)\n      OptiEdges:     1              (4)\nLinkConstraints:     1              (4)\n sub-OptiGraphs:     3              (3)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"graph0 now contains 1 local link-constraint, and 4 total link-constraints (3 from the subgraphs). Here, the local link-constraint in graph0 is a global constraint to the entire optigraph that connects each of its subgraphs. This hierarchical construction is often useful for constructing more complex optimization problems separately and then coupling them in a higher level optigraph.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"We can lastly plot the hierarchical optigraph and see the nested subgraph structure.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"    using Plasmo\n\n    graph1 = OptiGraph()\n    @optinode(graph1,n1)\n    @optinode(graph1,nodes[2:3])\n\n    for node in optinodes(graph1)\n        @variable(node,x >= 0)\n        @variable(node, y >= 2)\n        @constraint(node,x + y >= 3)\n        @objective(node, Min, y)\n    end\n\n    @linkconstraint(graph1, n1[:x] + nodes[2][:x] + nodes[3][:x] == 3)\n\n    graph2 = OptiGraph();\n\n    @optinode(graph2,nodes2[1:3]);\n\n    for node in optinodes(graph2)\n        @variable(node, x >= 0)\n        @variable(node, y >= 2)\n        @constraint(node,x + y >= 5)\n        @objective(node, Min, y)\n    end\n\n    @linkconstraint(graph2, nodes2[1][:x] + nodes2[2][:x] + nodes2[3][:x] == 5);\n\n    graph3 = OptiGraph();\n\n    @optinode(graph3,nodes3[1:3]);\n\n    for node in optinodes(graph3)\n        @variable(node, x >= 0)\n        @variable(node, y >= 2)\n        @constraint(node,x + y >= 5)\n        @objective(node, Min, y)\n    end\n\n    @linkconstraint(graph3, nodes3[1][:x] + nodes3[2][:x] + nodes3[3][:x] == 7)\n\n    graph0 = OptiGraph()\n    add_subgraph!(graph0,graph1)\n    add_subgraph!(graph0,graph2)\n    add_subgraph!(graph0,graph3)\n\n    @linkconstraint(graph0,nodes[3][:x] + nodes2[2][:x] + nodes3[1][:x] == 10)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"using PlasmoPlots\n\nfor (i,node) in enumerate(all_nodes(graph0))\n    set_label(node, \"n$i\")\nend\n\nplt_graph0 = PlasmoPlots.layoutplot(graph0,\n                                    node_labels=true,\n                                    markersize=60,\n                                    labelsize=30,\n                                    linewidth=4,\n                                    subgraph_colors=true,\n                                    layout_options = Dict(:tol=>0.001,\n                                                     :C=>2,\n                                                     :K=>4,\n                                                     :iterations=>5))\n\nplt_matrix0 = PlasmoPlots.matrix(graph0,\n                                 node_labels = true,\n                                 subgraph_colors = true,\n                                 markersize = 16)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"(Image: graph_modeling2) (Image: matrix_modeling2)","category":"page"},{"location":"documentation/modeling/#Query-OptiGraph-Attributes","page":"Modeling with OptiGraphs","title":"Query OptiGraph Attributes","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"There are many functions in Plasmo.jl used to query optigraph attributes (see the API Documentation for a full list). We can use optinodes to retrieve an array of the local optinodes in an optigraph, whereas all_nodes will recursively retrieve all of the optinodes in an optigraph, including the optinodes in its subgraphs.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> optinodes(graph1)\n3-element Vector{OptiNode}:\n OptiNode w/ 2 Variable(s) and 2 Constraint(s)\n OptiNode w/ 2 Variable(s) and 2 Constraint(s)\n OptiNode w/ 2 Variable(s) and 2 Constraint(s)\n\njulia> optinodes(graph0)\nOptiNode[]\n\njulia> all_nodes(graph0)\n9-element Vector{OptiNode}:\n OptiNode w/ 2 Variable(s) and 2 Constraint(s)\n OptiNode w/ 2 Variable(s) and 2 Constraint(s)\n OptiNode w/ 2 Variable(s) and 2 Constraint(s)\n OptiNode w/ 2 Variable(s) and 1 Constraint(s)\n OptiNode w/ 2 Variable(s) and 1 Constraint(s)\n OptiNode w/ 2 Variable(s) and 1 Constraint(s)\n OptiNode w/ 2 Variable(s) and 1 Constraint(s)\n OptiNode w/ 2 Variable(s) and 1 Constraint(s)\n OptiNode w/ 2 Variable(s) and 1 Constraint(s)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"It is also possible to query for optiedges in the same way using optiedges and all_edges.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> optiedges(graph1)\n1-element Vector{OptiEdge}:\n OptiEdge w/ 1 Constraint(s)\n\njulia> optiedges(graph0)\n1-element Vector{OptiEdge}:\n OptiEdge w/ 1 Constraint(s)\n\njulia> all_edges(graph0)\n4-element Vector{OptiEdge}:\n OptiEdge w/ 1 Constraint(s)\n OptiEdge w/ 1 Constraint(s)\n OptiEdge w/ 1 Constraint(s)\n OptiEdge w/ 1 Constraint(s)","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"We can query link-constraints using linkconstraints and all_linkconstraints.","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> linkconstraints(graph1)\n1-element Vector{LinkConstraintRef}:\n linkconref: n1[:x] + nodes[2][:x] + nodes[3][:x] = 3.0\n\njulia> linkconstraints(graph0)\n1-element Vector{LinkConstraintRef}:\n : nodes[3][:x] + nodes2[2][:x] + nodes3[1][:x] = 10.0\n\njulia> all_linkconstraints(graph0)\n4-element Vector{LinkConstraintRef}:\n linkconref: n1[:x] + nodes[2][:x] + nodes[3][:x] = 3.0\n : nodes2[1][:x] + nodes2[2][:x] + nodes2[3][:x] = 5.0\n : nodes3[1][:x] + nodes3[2][:x] + nodes3[3][:x] = 7.0\n : nodes[3][:x] + nodes2[2][:x] + nodes3[1][:x] = 10.0","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"We can lastly query subgraphs using subgraphs and all_subgraphs","category":"page"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"julia> subgraphs(graph0)\n3-element Vector{OptiGraph}:\n       OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     3              (3)\n      OptiEdges:     1              (1)\nLinkConstraints:     1              (1)\n sub-OptiGraphs:     0              (0)\n       OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     3              (3)\n      OptiEdges:     1              (1)\nLinkConstraints:     1              (1)\n sub-OptiGraphs:     0              (0)\n       OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     3              (3)\n      OptiEdges:     1              (1)\nLinkConstraints:     1              (1)\n sub-OptiGraphs:     0              (0)","category":"page"},{"location":"documentation/modeling/#Managing-Multiple-OptiGraphs","page":"Modeling with OptiGraphs","title":"Managing Multiple OptiGraphs","text":"","category":"section"},{"location":"documentation/modeling/","page":"Modeling with OptiGraphs","title":"Modeling with OptiGraphs","text":"note: Note\nDocumentation Coming Soon!","category":"page"},{"location":"tutorials/gas_pipeline/#Optimal-Control-of-a-Natural-Gas-Network","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"","category":"section"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"This tutorial shows how to model a natural-gas network optimal control problem by constructing a hierarchical optigraph.   We show the resulting structure of the optimization problem and demonstrate how to use Plasmo.jl to partition and decompose the problem. The details of this model and a description of its parameters can be found in this manuscript. The actual implementation of this tutorial can be found in this git repository.","category":"page"},{"location":"tutorials/gas_pipeline/#Problem-Description","page":"Optimal Control of a Natural Gas Network","title":"Problem Description","text":"","category":"section"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"We consider the system of connected pipelines in series shown in the below figure. This linear network includes a gas supply at one end, a time-varying demand at the other end, and twelve compressor stations. The gas junctions connect thirteen pipelines which forms an optigraph with a linear topology.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"(Image: 13pipeline_sketch)","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"We seek to solve an optimal control problem that maximizes revenue over a 24 hour time period given a forecast of gas demand profiles. That is, we wish to obtain a compressor control policy that will meet the gas demand at junction j_25, whilst simultaneously minimizing compressor costs and meeting operational constraints. In the formulation below, alpha_ell and P_ellt are the compression cost ($/kW), and compression power for each compressor ell at time t, and alpha_d and f^target_dt are the demand price and target demand flow for each demand d at time t. This formulation includes physical equations and constraints that describe the network junctions, the pipeline dynamics, and compressors.   The network link equations describe how the devices within the topology are coupled together such as conservation of mass and boundary conditions. The sets that describe the elements of the optimization problem are also presented here.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"beginaligned\n    min_ substack  eta_elltf_jdt   ell in mathcalL_c d in mathcalD_j j in mathcalJ t in mathcalT quad \n    sum_substackell in mathcalL_c  t in mathcalT alpha_ell P_ellt -\n    sum_substackd in mathcalD_j j in mathcalJ   t in mathcalT alpha_jd f_jdt \n     st quad  textJunction Limits   \n      textPipeline Dynamics    \n      textCompressor Equations   \n      textNetwork Link Equations \nendaligned","category":"page"},{"location":"tutorials/gas_pipeline/#Sets-used-for-optimization-problem","page":"Optimal Control of a Natural Gas Network","title":"Sets used for optimization problem","text":"","category":"section"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"Set Description Elements\nmathcalJ Set of gas network nodes j in mathcalJ\nmathcalS Set of gas supplies s in mathcalS\nmathcalD Set of gas demands d in mathcalD\nmathcalD_j Set of gas demands on junction j d in mathcalD_j\nmathcalS_j Set of gas supplies on junction j s in mathcalS_j\nmathcalL Set of gas network links ell in mathcalL\nmathcalL_p Set of network pipeline links mathcalL_p subseteq mathcalL\nmathcalL_c Set of network compressor links mathcalL_c subseteq mathcalL\nmathcalX Set of spatial discretization points k in mathcalX\nmathcalT Set of temporal discretization points t in mathcalT","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"The following sections describe each component of the network in further detail.","category":"page"},{"location":"tutorials/gas_pipeline/#Junction-OptiGraph","page":"Optimal Control of a Natural Gas Network","title":"Junction OptiGraph","text":"","category":"section"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"The gas junctions in a gas network describe the connection points between pipelines and compressors.  The junction model is described by the below equations, where theta_jt is the pressure at junction j and time t. underlinetheta_j is the lower pressure bound for the junction, overlinetheta_j is the upper pressure bound, f_jdt^target is the target demand flow for demand d on junction j and overlinef_js is the available gas generation from supply s on junction j.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"beginaligned\n     underlinetheta_j le theta_jt le overlinetheta_j  quad j in mathcalJ  t in mathcalT \n    0 le f_jdt le f_jdt^target quad d in mathcalD_j  j in mathcalJ  t in mathcalT \n    0 le f_jst le overlinef_js quad s in mathcalS_j  j in mathcalJ  t in mathcalT\nendaligned","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"The optigraph that is used to create the junction model is given by the following julia function.  We define the function create_junction_model which accepts junction specific data and the number of time periods nt.  We create the optigraph graph, add an optignode for each time interval (using @optinode), and then create the variables and constraints for each node in a loop.  We also use the JuMP specific @expression macro to refer to expressions for total gas supplied, total gas delivered, and total cost for convenience.  The junction optigraph is finally returned from the function","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"#Define function to create junction model-graph\nfunction create_junction_model(data,nt)            \n    graph = OptiGraph()                           \n\n    #Add model-node for each time interval\n    @optinode(graph,nodes[1:nt])\n\n    #query number of supply and demands on the junction\n    n_demands = length(data[:demand_values])\n    n_supplies = length(data[:supplies])\n\n    #Loop and create variables, constraints, and objective for each model-node\n    for (i,node) in enumerate(nodes)\n        @variable(node, data[:pmin] <= pressure <= data[:pmax], start = 60)\n        @variable(node, 0 <= fgen[1:n_supplies] <= 200, start = 10)\n        @variable(node, fdeliver[1:n_demands] >= 0)\n        @variable(node, fdemand[1:n_demands] >= 0)\n\n        @constraint(node,[d = 1:n_demands],fdeliver[d] <= fdemand[d])\n\n        @expression(node, total_supplied, sum(fgen[s] for s = 1:n_supplies))\n        @expression(node, total_delivered,sum(fdeliver[d] for d = 1:n_demands))\n        @expression(node, total_delivercost,sum(1000*fdeliver[d] for d = 1:n_demands))\n\n        @objective(node,Min,total_delivercost)\n    end                                             \n\n    #Return the junction OptiGraph\n    return graph                                   \nend","category":"page"},{"location":"tutorials/gas_pipeline/#Compressor-OptiGraph","page":"Optimal Control of a Natural Gas Network","title":"Compressor OptiGraph","text":"","category":"section"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"Compressors constitute the primary control decisions in the optimal control problem and are described by the following simple formulation. We use an ideal isentropic compressor model where eta_ellt, p_ellt^in, and p_ellt^out are the compression ratio, suction pressure, and discharge pressure at time t, and P_ellt is power at time t. We also introduceduce the dummy variables f_ellt^in and f_ellt^out to be consistent with the pipeline model in the next section.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"beginaligned\n    p_ellt^out = eta_ellt p_ellt^in quad ell in mathcalL_cquad t in mathcalT \n    P_ellt = c_p cdot T cdot f_ellt left(left(fracp_ellt^outp_ellt^inright)^fracgamma-1gamma-1right)\n    quad ell in mathcalL_cquad t in mathcalT\n    f_ellt = f_ellt^in = f_ellt^out quad ell in mathcalL_cquad t in mathcalT\nendaligned","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"The compressor optigraph construction is straightforward as shown by the following Julia code. Like the above model, we define a function called create_compressor_model to create a compressor optigraph given data and number of time periods nt. We create the compressor optigraph by creating nodes, variables, and constraints, as well as expressions to refer to flow in and out of each compressor. We lastly return the created optigraph from the function.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"function create_compressor_model(data,nt)                        \n    #Create compressor model-graph\n    graph = OptiGraph()                                          \n    @optinode(graph,nodes[1:nt])\n\n    #Setup variables, constraints, and objective\n    for node in nodes\n        @variable(node, 1 <= psuction <= 100)\n        @variable(node, 1 <= pdischarge <= 100)\n        @variable(node, 0 <= power <= 1000)\n        @variable(node, flow >= 0)\n        @variable(node, 1 <= eta <= 2.5)\n        @NLconstraint(node, pdischarge == eta*psuction)\n        @NLconstraint(node, power == c4*flow*((pdischarge/psuction)^om-1) )\n        @objective(node, Min, cost*power*(dt/3600.0))\n    end                                                         \n\n    #Create references for flow in and out\n    @expression(graph,fin[t=1:nt],nodes[t][:flow])               \n    @expression(graph,fout[t=1:nt],nodes[t][:flow])          \n\n    #Return compressor OptiGraph\n    return graph                                              \nend","category":"page"},{"location":"tutorials/gas_pipeline/#Pipeline-OptiGraph","page":"Optimal Control of a Natural Gas Network","title":"Pipeline OptiGraph","text":"","category":"section"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"We now implement the pipeline equations to describe the dynamic transport throughout the gas network. For each pipeline model we assume isothermal flow through horizontal segments with constant pipe friction.  We ultimately produce the following discretized pipeline model.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"beginaligned\n     fracp_ellt+1k - p_elltkDelta t = -c_1ell fracf_ellt+1k+1 - f_ellt+1kDelta x_ell ell in mathcalL_pt in mathcalT k in mathcalX_ell \n     fracf_ellt+1k - f_elltkDelta t = -c_2ellfracp_ellt+1k+1 - p_ellt+1kDelta x_ell - c_3ellfracf_ellt+1k f_ellt+1kp_ellt+1k ell in mathcalL_p t in mathcalT k in mathcalX_ell  \n     f_elltN_x = f_ellt^outquad ell in mathcalL_p quad t in mathcalT \n     f_ellt1 = f_ellt^inquad ell in mathcalL_p quad t in mathcalT    \n     p_elltN_x = p_ellt^outquad ell in mathcalL_p quad t in mathcalT \n     p_ellt1 = p_ellt^inquad ell in mathcalL_p quad t in mathcalT    \nendaligned","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"The model contains the transport equations defined in terms of pressure and mass flow rate.  It also contains dummy flows and pressures which represent in the inlet and outlet flow and pressure into each pipeline segment.  We also express a steady-state initial condition which is typical for this control problem and is given by the following equations.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"beginaligned\n     fracf_ell1k+1 - f_ell1kDelta x = 0  quad ell in mathcalL_p k in mathcalX_ell \n     c_2ellfracp_ell1k - p_ell1kDelta x + c_3fracf_ell1k f_ell1kp_ell1k = 0\n    quad ell in mathcalL_p k in mathcalX_ell\nendaligned","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"Lastly, we require the total line-pack in each segment (i.e. the inventory of gas) to be refilled at the end of the planning horizon. This is represented by the following approximation of line-pack and constraint for refilling it.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"beginaligned\n     m_ellt = fracA_ellc^2 sum_k=1^N_x p_elltk Delta x_ellquad ell in mathcalL_p t in mathcalT \n     m_ellN_t ge m_ell1 quad ell in mathcalL_p\nendaligned","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"We express the pipeline model with optinodes distributed on a space-time grid. Specifically, the nodes of each pipeline optigraph form a nt x nx  grid wherein pressure and flow variables are assigned to each node. Flow dynamics within pipelines are then expressed with linking constraints that describe the discretized PDE equations for mass and momentum using finite differences. We lastly include linking constraints that represent the initial steady-state condition and line-pack constraint.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"function create_pipeline_model(data,nt,nx)                             \n    #Unpack data\n    c1 = data[:c1]; c2 = data[:c2]; c3 = data[:c3]                     \n    dx = data[:pipe_length] / (nx - 1)\n\n    #Create pipeline model-graph\n    graph = OptiGraph()\n\n    #Create grid of optinodes\n    @node(mg,grid[1:nt,1:nx])                                         \n\n    #Create variables on each node in the grid\n    for node in grid\n        @variable(node, 1 <= px <= 100)\n        @variable(node, 0 <= fx <= 100)\n        @variable(node, slack >= 0)\n        @NLconstraint(node, slack*px - c3*fx*fx == 0)\n    end\n\n    #Setup dummy variable references\n    @expression(mg, fin[t=1:nt], grid[:,1][t][:fx])\n    @expression(mg, fout[t=1:nt], grid[:,end][t][:fx])\n    @expression(mg, pin[t=1:nt], grid[:,1][t][:px])\n    @expression(mg, pout[t=1:nt], grid[:,end][t][:px])\n    @expression(mg, linepack[t=1:nt], c2/A*sum(grid[t,x][:px]*dx for x in 1:nx-1))          \n\n    #Finite differencing.  Backward difference in time from t, Forward difference in space from x.\n    @linkconstraint(mg, press[t=2:nt,x=1:nx-1],                                            \n    (grid[t,x][:px]-grid[t-1,x][:px])/dt +\n    c1*(grid[t,x+1][:fx] - grid[t,x][:fx])/dx == 0)\n\n    @linkconstraint(mg, flow[t=2:nt,x=1:nx-1], (grid[t,x][:fx] -\n    grid[t-1,x][:fx])/dt == -c2*(grid[t,x+1][:px] -\n    grid[t,x][:px])/dx - grid[t,x][:slack])\n\n    #Initial steady state\n    @linkconstraint(mg, ssflow[x=1:nx-1], grid[1,x+1][:fx] - grid[1,x][:fx] == 0)\n    @linkconstraint(mg, sspress[x = 1:nx-1], -c2*(grid[1,x+1][:px] -\n    grid[1,x][:px])/dx - grid[1,x][:slack] == 0)\n\n    #Refill pipeline linepack\n    @linkconstraint(mg, linepack[end] >= linepack[1])                     \n    return graph\nend","category":"page"},{"location":"tutorials/gas_pipeline/#Network-OptiGraph","page":"Optimal Control of a Natural Gas Network","title":"Network OptiGraph","text":"","category":"section"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"The network connections define the topology that connect junctions and equipment links (i.e. pipelines and compressors). Specifically, the network equations express mass conservation around each junction and boundary conditions for pipelines and compressors. Mass conservation around each junction j is given by the following equation.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"beginaligned\n     sum_ellinmathcalL_rec(j) f^out_ellt - sum_ell inmathcalL_snd(j) f^in_ellt +\n    sum_sinmathcalS_jf_jst - sum_din mathcalD_jf_jdt = 0 quad j inmathcalJ\nendaligned","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"where we define mathcalL_rec(j) and mathcalL_snd(j) as the set of receiving and sending links to each junction j respectively.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"The next equations define pipeline and compressor link boundary conditions.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"beginaligned\n     p_ellt^in =  theta_rec(ell)t quad ell in mathcalL  t in mathcalT \n     p_ellt^out = theta_snd(ell)t quad ell in mathcalL  t in mathcalT\nendaligned","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"Here, theta_rec(ell)t and theta_snd(ell)t are the receiving and sending junction pressure for each link ell in mathcalL at time t.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"The Julia code required to create the network optigraph is a bit more involved, but mostly because we have to define some data structures to capture the network topology. The below piece of code defines the function create_gas_network which accepts a dictionary of network data and calls the above defined functions to create the hierarchical optigraph. That is, the below code creates junction, compressor, and pipeline optigraphs, adds these optigraphs as subgraphs within a higher level network optigraph, and then creates linking constraints that couple the subgraphs to eachother in the form of mass conservation and boundary conditions.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"function create_gas_network(net_data)              \n    pipe_data = net_data[:pipeline_data]\n    comp_data = net_data[:comp_data]\n    junc_data = net_data[:junc_data]\n    pipe_map = net_data[:pipe_map]; comp_map = net_data[:comp_map]\n\n    #Create OptiGraph for entire gas network\n    network = OptiGraph()                              \n    network[:pipelines] = [];network[:compressors] = [];network[:junctions] = []\n    j_map = Dict()\n\n    #Create device OptiGraphs and setup data structures\n    for j_data in junc_data                                 \n        junc= create_junction_optigraph(j_data)\n        add_subgraph!(network,junc); push!(network[:junctions],junc)\n        j_map[j_data[:id]] = junc\n        junc[:devices_in] = []; junc[:devices_out] = []\n    end\n    for p_data in pipe_data\n        pipe = create_pipeline_optigraph(p_data); push!(network[:pipelines],pipe)\n        add_subgraph!(network,pipe);\n        pipe[:junc_from] = j_map[p_data[:junc_from]]\n        pipe[:junc_to] = j_map[p_data[:junc_to]]\n        push!(pipe[:junc_from][:devices_out],pipe); push!(pipe[:junc_to][:devices_in],pipe)\n    end\n    for c_data in comp_data\n        comp = create_compressor_optigraph(c_data)\n        add_subgraph!(gas_network,comp); comp[:data] = c_data\n        comp[:junc_from] = j_map[c_data[:junc_from]]\n        comp[:junc_to] = j_map[c_data[:junc_to]]\n        push!(comp[:junc_from][:devices_out],comp); push!(comp[:junc_to][:devices_in],comp)\n    end                                                       \n\n    #Link pipelines in gas network\n    for pipe in network[:pipelines]                         \n        junc_from,junc_to = [pipe[:junc_from],pipe[:junc_to]]\n        @linkconstraint(network,[t = 1:nt],pipe[:pin][t] == junc_from[:pressure][t])\n        @linkconstraint(gas_network,[t = 1:nt],pipe[:pout][t] == junc_to[:pressure][t])\n    end\n\n    #Link compressors in gas network\n    for comp in network[:compressors]\n        junc_from,junc_to = [comp[:junc_from].comp[:junc_to]]\n        @linkconstraint(network,[t = 1:nt],comp[:pin][t] == junc_from[:pressure][t])\n        @linkconstraint(network,[t = 1:nt],comp[:pout][t]  == junc_to[:pressure][t])\n    end\n\n    #Link junctions in gas network\n    for junc in network[:junctions]\n        devices_in = junc[:devices_in]; devices_out = junc[:devices_out]\n\n        flow_in = [sum(device[:fout][t] for device in devices_in) for t = 1:nt]\n        flow_out = [sum(device[:fin][t] for device in devices_out) for t = 1:nt]\n\n        total_supplied = [junction[:total_supplied][t] for t = 1:nt]\n        total_delivered = [junction[:total_delivered][t] for t = 1:nt]\n\n        @linkconstraint(gas_network,[t = 1:nt], flow_in[t] - flow_out[t] +\n        total_supplied[t] - total_delivered[t] == 0)\n    end                                                 \n    return gas_network\nend","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"Using the above function, we can obtain a complete optigraph representation of the optimal control problem. It is now possible to plot the graph layout using Plotting functions or export the graph structure and use another graph visualization tool. Gephi was used to produce the below figure. Here, the green colors correspond to compressor nodes, blue corresponds to junctions, and grey corresponds to pipelines.  Notice that the optigraph captures the space-time structure of the optimization problem.   We also observe a cylindrical shape to the problem which results from the line-pack constraint which couples the initial and final time optinodes for each pipeline.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"(Image: space_time)","category":"page"},{"location":"tutorials/gas_pipeline/#Partitioning","page":"Optimal Control of a Natural Gas Network","title":"Partitioning","text":"","category":"section"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"Now that we have an optigraph representation of our optimal control problem, we can use hypergraph partitioning to decompose the space-time structure. To do so, we use KaHyPar and the functions described in Graph Partitioning and Processing. the below code creates a hypergraph representation of the optigraph, sets up node and edge weights, partitions the problem, and forms new subgraphs based on the partitions.   We also aggregate the subgraphs to produce solvable optinode subproblems which will communicate to our solver.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"#Import the KaHyPar interface\nusing KaHyPar         \n\n#Get the hypergraph representation of the gas network\nhgraph,ref_map = hyper_graph(gas_network)     \n\n#Setup node and edge weights\nn_vertices = length(vertices(hgraph))              \nnode_weights = [num_variables(node) for node in all_nodes(gas_network)]\nedge_weights = [num_linkconstraints(edge) for edge in all_edges(gas_network)]  \n\n#Use KaHyPar to partition the hypergraph\nnode_vector = KaHyPar.partition(hypergraph,\n                                13,\n                                configuration=:edge_cut,\n                                imbalance=0.01,\n                                node_weights=node_weights,\n                                edge_weights=edge_weights)      \n\n#Create a Partition object\npartition = Partition(node_vector, ref_map)           \n\n#Setup subgraphs based on the partition\napply_partition!(gas_network, partition)             \n\n#Aggregate the subgraphs into OptiNodes which can be solved\nnew_graph , aggregate_map  = aggregate(gas_network, 0)        ","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"The partitioned optimal control problem is visualized in the below figure and depicts the optimization problem partitioned into 13 distinct partitions.","category":"page"},{"location":"tutorials/gas_pipeline/","page":"Optimal Control of a Natural Gas Network","title":"Optimal Control of a Natural Gas Network","text":"(Image: partition)","category":"page"},{"location":"documentation/partitioning/#Graph-Partitioning-and-Processing","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"The Modeling with OptiGraphs section describes how to construct optigraphs using a bottom-up approach with a focus on Hierarchical Modeling using Subgraphs to create multi-level optigraphs. Plasmo.jl also supports creating multi-level optigraphs using a top-down approach. This is done using the optigraph partition functions and interfaces to standard graph partitioning tools such as Metis and KaHyPar.","category":"page"},{"location":"documentation/partitioning/#Example-Partitioning-Problem:-Dynamic-Optimization","page":"Graph Partitioning and Processing","title":"Example Partitioning Problem: Dynamic Optimization","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"To help demonstrate graph partitioning capabilities in Plasmo.jl, we instantiate a simple optimal control problem described by the following equations. In this problem, x is a vector of states and u is a vector of control actions which are both indexed over the set of time indices t in 1T. The objective function minimizes the state trajectory with minimal control effort, the second equation describes the state dynamics, and the third equation defines the initial condition. The last two equations define limits on the state and control actions.","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"    DocTestSetup = quote\n    using Plasmo\n\n    T = 100          #number of time points\n    d = sin.(1:T)    #disturbance vector\n\n    graph = OptiGraph()\n    @optinode(graph,state[1:T])\n    @optinode(graph,control[1:T-1])\n\n    for node in state\n        @variable(node,x)\n        @constraint(node, x >= 0)\n        @objective(node,Min,x^2)\n    end\n    for node in control\n        @variable(node,u)\n        @constraint(node, u >= -1000)\n        @objective(node,Min,u^2)\n    end\n\n    @linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\n    n1 = state[1]\n    @constraint(n1,n1[:x] == 0)\nend","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"beginaligned\n    min_ xu   sum_t = 1^T x_t^2 + u_t^2   \n    textrmst quad  x_t+1 = x_t + u_t + d_t quad t in 1T-1   \n     x_1 = 0  \n     x_t ge 0 quad t in 1T\n     u_t ge -1000 quad t in 1T-1\nendaligned","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"This snippet shows how to construct the optimal control problem in Plasmo.jl. We create an optigraph, add optinodes which represent states and controls at each time period, we set objective functions for each optinode, and we use link-constraints to describe the dynamics.","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"using Plasmo\n\nT = 100          #number of time points\nd = sin.(1:T)    #disturbance vector\n\ngraph = OptiGraph()\n@optinode(graph,state[1:T])\n@optinode(graph,control[1:T-1])\n\nfor node in state\n    @variable(node,x)\n    @constraint(node, x >= 0)\n    @objective(node,Min,x^2)\nend\nfor node in control\n    @variable(node,u)\n    @constraint(node, u >= -1000)\n    @objective(node,Min,u^2)\nend\n\n@linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\nn1 = state[1]\n@constraint(n1,n1[:x] == 0)","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"When we print the newly created optigraph for our optimal control problem, we see it contains about 200 optinodes (one for each state and control) and contains almost 100 linking constraints (which couple the time periods).","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"julia> println(graph)\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:   199            (199)\n      OptiEdges:    99             (99)\nLinkConstraints:    99             (99)\n sub-OptiGraphs:     0              (0)","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"    DocTestSetup = nothing","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"We can also plot the resulting optigraph (see Plotting) which produces a simple chain of optinodes.","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"    using Plasmo\n\n    T = 100         \n    d = sin.(1:T)   \n\n    graph = OptiGraph()\n    @optinode(graph,state[1:T])\n    @optinode(graph,control[1:T-1])\n\n    for node in state\n        @variable(node,x)\n        @constraint(node, x >= 0)\n        @objective(node,Min,x^2)\n    end\n    for node in control\n        @variable(node,u)\n        @constraint(node, u >= -1000)\n        @objective(node,Min,u^2)\n    end\n\n    @linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\n    n1 = state[1]\n    @constraint(n1,n1[:x] == 0)","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"using PlasmoPlots\n\nplt_chain_layout = layout_plot(graph,\n                               layout_options=Dict(:tol=>0.1,:iterations=>500),\n                               linealpha = 0.2,\n                               markersize = 6)\n\nplt_chain_matrix = matrix_plot(graph)","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"(Image: partition_layout_1) (Image: partition_matrix_1)","category":"page"},{"location":"documentation/partitioning/#Partitioning-OptiGraphs","page":"Graph Partitioning and Processing","title":"Partitioning OptiGraphs","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"At its core, the OptiGraph is a hypergraph and can naturally interface to hypergraph partitioning tools.   For our example here we demonstrate how to use hypergraph partitioning (using KaHyPar), but Plasmo.jl also supports standard graph partitioning algorithms using graph projections. The below snippet uses the hyper_graph function which returns a Plasmo.HyperGraph object and a hyper_map (a Julia dictionary) which maps hypernodes and hyperedges back to the original optigraph.","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"julia> hgraph, hyper_map = hyper_graph(graph);\n\njulia> println(hgraph)\nHypergraph: (199 , 99)","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"    DocTestSetup = quote\n    using Plasmo\n    using KaHyPar\n    using Suppressor\n\n    T = 100         \n    d = sin.(1:T)   \n\n    graph = OptiGraph()\n    @optinode(graph,state[1:T])\n    @optinode(graph,control[1:T-1])\n\n    for node in state\n        @variable(node,x)\n        @constraint(node, x >= 0)\n        @objective(node,Min,x^2)\n    end\n    for node in control\n        @variable(node,u)\n        @constraint(node, u >= -1000)\n        @objective(node,Min,u^2)\n    end\n\n    @linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])\n    n1 = state[1]\n    @constraint(n1,n1[:x] == 0)\n\n    hgraph,hyper_map = hyper_graph(graph)\n    partition_vector = @suppress KaHyPar.partition(hgraph, 8, configuration = :connectivity, imbalance = 0.01)\n    partition = Partition(partition_vector, hyper_map)\n    apply_partition!(graph, partition)\nend","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"With our hypergraph we can now perform hypergraph partitioning in the next snippet which returns a partition_vector. Each index in the partition_vector corresponds to a hypernode in hypergraph, and each value denotes which partition the hypernode belongs to. So in our example, partition_vector contains 199 elements which take on integer values between 0 and 7 (for 8 total partitions). Once we have a partition_vector, we can create a Partition object which describes partitions of optinodes and optiedges, as well as the shared optinodes and optiedges that cross partitions. We can lastly use the produced partition object to formulate subgraphs in our original optigraph (graph) using apply_partition!. After doing so, we see that our graph now contains 8 subgraphs with 7 link-constraints that correspond to the optiedges that cross partitions (i.e. connect subgraphs).","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"julia> using KaHyPar\n\njulia> partition_vector = KaHyPar.partition(hypergraph,\n                                            8,\n                                            configuration=:connectivity,\n                                            imbalance=0.01);\n\njulia> partition = Partition(partition_vector, hyper_map);\n\njulia> apply_partition!(graph, partition);","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"note: Note\nPlasmo.jl contains a direct interface to KaHyPar which is used here. However, a user can always provide the partition_vector themselves using some other partitioning or community detection approach.","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"julia> length(partition_vector)\n199\n\njulia> partition\nOptiGraph Partition w/ 8 subpartitions\n\njulia> num_subgraphs(graph)\n8\n\njulia> num_linkconstraints(graph)\n7\n\njulia> num_all_linkconstraints(graph)\n99","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"If we plot the partitioned optigraph, it reveals eight distinct partitions and the coupling between them. The plots show that the partitions are well-balanced and the matrix visualization shows the problem is reordered into a banded structure that is typical of dynamic optimization problems.","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"plt_chain_partition_layout = layout_plot(graph,\n                                         layout_options=Dict(:tol=>0.01,\n                                                        :iterations=>500),\n                                         linealpha=0.2,\n                                         markersize=6,\n                                         subgraph_colors=true)\n\nplt_chain_partition_matrix = matrix_layout(graph, subgraph_colors=true)\n","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"(Image: partition_layout_2) (Image: partition_matrix_2)","category":"page"},{"location":"documentation/partitioning/#Aggregating-OptiGraphs","page":"Graph Partitioning and Processing","title":"Aggregating OptiGraphs","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"Subgraphs can be converted into stand-alone optinodes using the using the aggregate function. This can be helpful when the user models using subgraphs, but they want to represent solvable subproblems using optinodes. In the snippet below, we aggregate our optigraph that contains 8 subgraphs.  We include the argument 0 which specifies how many subgraph levels to retain.  In this case, 0 means we aggregate subgraphs at the highest level so graph contains only new aggregated optinodes. For hierarchical graphs with many levels, we can define how many subgraph levels we wish to retain. The function returns a new aggregated graph (aggregate_graph), as well as a reference_map which maps elements in aggregate_graph to the original optigraph graph.","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"julia> aggregate_graph,reference_map = aggregate(graph,0);\nAggregating OptiGraph with a maximum subgraph depth of 0\n\njulia> println(aggregate_graph)\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     8              (8)\n      OptiEdges:     7              (7)\nLinkConstraints:     7              (7)\n sub-OptiGraphs:     0              (0)","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"note: Note\nA user can also use aggregate! to permanently aggregate an existing optigraph. This avoids maintaining a copy of the original optigraph.","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"We can lastly plot the aggregated graph structure which simply shows 8 optinodes with 7 linking constraints.","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"plt_chain_aggregate = layout_plot(aggregate_graph,\n                                  layout_options=Dict(:tol=>0.01,:iterations=>10),\n                                  node_labels=true,\n                                  markersize=30,\n                                  labelsize=20,\n                                  node_colors=true)\n\nplt_chain_matrix_aggregate = matrix_plot(aggregate_graph,\n                                         node_labels=true,\n                                         node_colors=true);\n","category":"page"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"(Image: partition_layout_3) (Image: partition_matrix_3)","category":"page"},{"location":"documentation/partitioning/#OptiGraph-Projections","page":"Graph Partitioning and Processing","title":"OptiGraph Projections","text":"","category":"section"},{"location":"documentation/partitioning/","page":"Graph Partitioning and Processing","title":"Graph Partitioning and Processing","text":"note: Note\nDocumentation coming soon!","category":"page"},{"location":"documentation/api_docs/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"documentation/api_docs/#OptiGraph","page":"API Documentation","title":"OptiGraph","text":"","category":"section"},{"location":"documentation/api_docs/","page":"API Documentation","title":"API Documentation","text":"OptiGraph\n@optinode\n@linkconstraint\noptigraph_reference\nadd_subgraph!\nsubgraph\nsubgraphs\nall_subgraphs\nsubgraph_by_index\nnum_subgraphs\nnum_all_subgraphs\nhas_subgraphs\nadd_node!\noptinode\noptinodes\nall_nodes\noptinode_by_index\nPlasmo.add_optiedge!\noptiedge\noptiedges\nall_edges\noptiedge_by_index\nlinkconstraints\nall_linkconstraints\nnum_linkconstraints\nhas_objective\nhas_nl_objective\nBase.getindex(::OptiGraph, ::OptiNode)\nBase.getindex(::OptiGraph, ::OptiEdge)","category":"page"},{"location":"documentation/api_docs/#Plasmo.OptiGraph","page":"API Documentation","title":"Plasmo.OptiGraph","text":"OptiGraph()\n\nCreate an empty OptiGraph. An OptiGraph extends a JuMP.AbstractModel and supports most JuMP.Model functions.\n\n\n\n\n\n","category":"type"},{"location":"documentation/api_docs/#Plasmo.@optinode","page":"API Documentation","title":"Plasmo.@optinode","text":"@optinode(optigraph, expr...)\n\nAdd a new optinode to optigraph. The expression expr can either be\n\nof the form nodename creating a single optinode with the variable name varname\nof the form nodename[...] or [...] creating a container of optinodes using JuMP Containers\n\n\n\n\n\n","category":"macro"},{"location":"documentation/api_docs/#Plasmo.@linkconstraint","page":"API Documentation","title":"Plasmo.@linkconstraint","text":"@linkconstraint(graph::OptiGraph, expr)\n\nAdd a linking constraint described by the expression expr.\n\n@linkconstraint(graph::OptiGraph, ref[i=..., j=..., ...], expr)\n\nAdd a group of linking  constraints described by the expression expr parametrized by i, j, ...\n\nThe @linkconstraint macro works the same way as the JuMP.@constraint macro.\n\n\n\n\n\n","category":"macro"},{"location":"documentation/api_docs/#Plasmo.optigraph_reference","page":"API Documentation","title":"Plasmo.optigraph_reference","text":"optigraph_reference(graph::OptiGraph)::OptiGraph\n\nCreate a new optigraph with the same optinodes and optiedges as graph. Useful for defining an optigraph over existing nodes and edges without recreating them. Note that any changes to the optinodes and optiedges in the returned optigraph will take place in the original graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.add_subgraph!","page":"API Documentation","title":"Plasmo.add_subgraph!","text":"add_subgraph!(graph::OptiGraph, subgraph::OptiGraph)::OptiGraph\n\nAdd the sub-optigraph subgraph to the higher level optigraph graph. Returns the original graph\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.subgraph","page":"API Documentation","title":"Plasmo.subgraph","text":"subgraph(graph::OptiGraph, idx::Int64)\n\nRetrieve the the subgraph in graph at index idx.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.subgraphs","page":"API Documentation","title":"Plasmo.subgraphs","text":"subgraphs(optigraph::OptiGraph)::Vector{OptiGraph}\n\nRetrieve the local subgraphs of optigraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.all_subgraphs","page":"API Documentation","title":"Plasmo.all_subgraphs","text":"all_subgraphs(graph::OptiGraph)::Vector{OptiGraph}\n\nRetrieve all of the contained subgraphs of graph, including nested subgraphs. The order of the subgraphs in the returned vector starts with the local subgraphs in optigraph and then appends the nested subgraphs for each local subgraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.subgraph_by_index","page":"API Documentation","title":"Plasmo.subgraph_by_index","text":"subgraph_by_index(graph::OptiGraph, index::Int64)::OptiGraph\n\nRecursively search optigraph graph for the subngraph at index by traversing subgraphs. Note that the subgraph is not unique to the index. Since the search is depth-first, the subgraph returned may be different if the overall graph structure changes.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.num_subgraphs","page":"API Documentation","title":"Plasmo.num_subgraphs","text":"num_subgraphs(graph::OptiGraph)::Int64\n\nRetrieve the number of local subgraphs in graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.num_all_subgraphs","page":"API Documentation","title":"Plasmo.num_all_subgraphs","text":"num_all_subgraphs(graph::OptiGraph)::Int64\n\nRetrieve the number of subgraphs in graph including nested subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.has_subgraphs","page":"API Documentation","title":"Plasmo.has_subgraphs","text":"has_subgraphs(graph::OptiGraph)::Bool\n\nCheck whether graph contains subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.add_node!","page":"API Documentation","title":"Plasmo.add_node!","text":"add_node!(graph::OptiGraph)::OptiNode\n\nCreate a new OptiNode and add it to graph. Returns the added optinode.\n\nadd_node!(graph::OptiGraph, m::JuMP.Model)::OptiNode\n\nAdd a new optinode to graph and set its model to the JuMP.Model m.\n\nadd_node!(graph::OptiGraph, optinode::OptiNode)::OptiNode\n\nAdd the existing optinode (Created with OptiNode()) to the optigraph graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.optinode","page":"API Documentation","title":"Plasmo.optinode","text":"optinode(m::JuMP.Model)\n\nRetrieve the optinode corresponding to JuMP model m\n\n\n\n\n\noptinode(var::JuMP.VariableRef)\n\nRetrieve the optinode corresponding to JuMP VariableRef\n\n\n\n\n\noptinode(var::JuMP.VariableRef)::OptiNode\n\nRetrieve the optinode corresponding to JuMP ConstraintRef\n\n\n\n\n\noptinode(graph::OptiGraph, index::Int64)\n\nRetrieve the local optinode in graph at index. This does not retrieve nodes in subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.optinodes","page":"API Documentation","title":"Plasmo.optinodes","text":"optinodes(graph::OptiGraph)::Vector{OptiNode}\n\nRetrieve the optinodes in graph. Note that this returns the local optinodes contained directly in graph and excludes nodes contained in subgraphs of graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.all_nodes","page":"API Documentation","title":"Plasmo.all_nodes","text":"all_nodes(graph::OptiGraph)::Vector{OptiNode}\n\nRecursively collect all optinodes in graph by traversing each of its subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.optinode_by_index","page":"API Documentation","title":"Plasmo.optinode_by_index","text":"optinode_by_index(graph::OptiGraph, index::Int64)::OptiNode\n\nRecursively search optigraph graph for the optinode at index by traversing subgraphs. Note that the optinode is not unique to the index. Since the search is depth-first, the optinode returned may be different if the subgraph structure changes.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.add_optiedge!","page":"API Documentation","title":"Plasmo.add_optiedge!","text":"add_optiedge!(graph::OptiGraph, optinodes::Vector{OptiNode})::OptiEdge\n\nAdd an optiedge to optigraph graph that connects optinodes. If edge already exists, return it.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.optiedge","page":"API Documentation","title":"Plasmo.optiedge","text":"optiedge(graph::OptiGraph, index::Int64)\n\nRetrieve the local optiedge in graph at index\n\noptiedge(graph::OptiGraph, nodes::OrderedSet{OptiNode})\n\nRetrieve the optiedge in graph that connects the optinodes in the OrderedSet of nodes.\n\noptiedge(graph::OptiGraph, nodes::OptiNode...)\n\nRetrieve the optiedge in graph that connects nodes.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.optiedges","page":"API Documentation","title":"Plasmo.optiedges","text":"optiedges(graph::OptiGraph)::Vector{OptiEdge}\n\nRetrieve the local optiedges in graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.all_edges","page":"API Documentation","title":"Plasmo.all_edges","text":"all_edges(graph::OptiGraph)::Vector{OptiEdge}\n\nRecursively collect all optiedges in graph by traversing each of its subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.optiedge_by_index","page":"API Documentation","title":"Plasmo.optiedge_by_index","text":"optiedge_by_index(graph::OptiGraph, index::Int64)::OptiEdge\n\nRecursively search optigraph graph for the edge at index by traversing subgraphs. Note that the edge is not unique to the index. Since the search is depth-first, the optiedge returned may be different if the subgraph structure changes.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.linkconstraints","page":"API Documentation","title":"Plasmo.linkconstraints","text":"linkconstraints(graph::OptiGraph)::Vector{LinkConstraintRef}\n\nRetrieve the local linking constraints in graph. Returns a vector of the linking constraints.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.all_linkconstraints","page":"API Documentation","title":"Plasmo.all_linkconstraints","text":"all_linkconstraints(graph::OptiGraph)::Vector{LinkConstraintRef}\n\nRecursively collect all linkconstraints in graph by traversing each of its subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.num_linkconstraints","page":"API Documentation","title":"Plasmo.num_linkconstraints","text":"num_linkconstraints(node::OptiNode)\n\nReturn the number of link-constraints incident to optinode node\n\n\n\n\n\nnum_linkconstraints(graph::OptiGraph)::Int64\n\nRetrieve the number of local linking constraints in graph. Does not include linkconstraints in subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.has_objective","page":"API Documentation","title":"Plasmo.has_objective","text":"has_objective(node::OptiNode)\n\nCheck whether optinode node has a non-empty linear or quadratic objective function\n\n\n\n\n\nhas_objective(graph::OptiGraph)::Bool\n\nCheck whether optigraph graph has an affine or quadratic objective function set.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.has_nl_objective","page":"API Documentation","title":"Plasmo.has_nl_objective","text":"has_nl_objective(node::OptiNode)\n\nCheck whether optinode node has a nonlinear objective function\n\n\n\n\n\nhas_nl_objective(graph::OptiGraph)::Bool\n\nCheck whether any optinode in graph has a nonlinear objective function.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Base.getindex-Tuple{OptiGraph, OptiNode}","page":"API Documentation","title":"Base.getindex","text":"Base.getindex(graph::OptiGraph, node::OptiNode)\n\nRetrieve the index of the optinode node in graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/api_docs/#Base.getindex-Tuple{OptiGraph, OptiEdge}","page":"API Documentation","title":"Base.getindex","text":"Base.getindex(graph::OptiGraph, optiedge::OptiEdge)::Int64\n\nRetrieve the index of the optiedge in graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/api_docs/#OptiNode","page":"API Documentation","title":"OptiNode","text":"","category":"section"},{"location":"documentation/api_docs/","page":"API Documentation","title":"API Documentation","text":"OptiNode\njump_model\nset_model\nlabel\nset_label\nis_node_variable\nis_set_to_node\nBase.getindex(node::OptiNode, symbol::Symbol)\nBase.setindex(node::OptiNode, value::Any, symbol::Symbol)\nnum_linked_variables","category":"page"},{"location":"documentation/api_docs/#Plasmo.OptiNode","page":"API Documentation","title":"Plasmo.OptiNode","text":"OptiNode()\n\nCreates an empty OptiNode.  Does not add it to an OptiGraph.\n\n\n\n\n\n","category":"type"},{"location":"documentation/api_docs/#Plasmo.jump_model","page":"API Documentation","title":"Plasmo.jump_model","text":"jump_model(node::OptiNode)\n\nGet the underlying JuMP.Model from the optinode node.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.set_model","page":"API Documentation","title":"Plasmo.set_model","text":"set_model(node::OptiNode, m::AbstractModel)\n\nSet the JuMP model m to optinode node.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.label","page":"API Documentation","title":"Plasmo.label","text":"label(node::OptiNode)\n\nGet the label for optinode node.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.set_label","page":"API Documentation","title":"Plasmo.set_label","text":"setlabel(node::OptiNode, label::Symbol)\n\nSet the label for optinode node to label. This is what gets printed.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.is_node_variable","page":"API Documentation","title":"Plasmo.is_node_variable","text":"is_node_variable(node::OptiNode, vref::JuMP.AbstractVariableRef)\n\nChecks whether the variable reference vref belongs to the optinode node.\n\n\n\n\n\nis_node_variable(vref::JuMP.AbstractVariableRef)\n\nChecks whether the variable reference vref belongs to any OptiNode.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.is_set_to_node","page":"API Documentation","title":"Plasmo.is_set_to_node","text":"is_set_to_node(m::JuMP.AbstractModel)\n\nChecks whether the JuMP model m is set to any OptiNode\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Base.getindex-Tuple{OptiNode, Symbol}","page":"API Documentation","title":"Base.getindex","text":"Base.getindex(node::OptiNode, symbol::Symbol)\n\nSupport retrieving node attributes via symbol lookup. (e.g. node[:x])\n\n\n\n\n\n","category":"method"},{"location":"documentation/api_docs/#Base.setindex-Tuple{OptiNode, Any, Symbol}","page":"API Documentation","title":"Base.setindex","text":"Base.setindex(node::OptiNode, value::Any, symbol::Symbol)\n\nSupport retrieving node attributes via symbol lookup. (e.g. node[:x])\n\n\n\n\n\n","category":"method"},{"location":"documentation/api_docs/#Plasmo.num_linked_variables","page":"API Documentation","title":"Plasmo.num_linked_variables","text":"num_linked_variables(node::OptiNode)\n\nReturn the number of node variables on node that are linked to other nodes\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#OptiEdge","page":"API Documentation","title":"OptiEdge","text":"","category":"section"},{"location":"documentation/api_docs/","page":"API Documentation","title":"API Documentation","text":"OptiEdge\nLinkConstraint\nLinkConstraintRef\nattached_node\nset_attached_node","category":"page"},{"location":"documentation/api_docs/#Plasmo.OptiEdge","page":"API Documentation","title":"Plasmo.OptiEdge","text":"OptiEdge\n\nThe OptiEdge type.  Typically created from @linkconstraint.  Contains the set of its supporting optionodes, as well as references to its underlying linking constraints.\n\n\n\n\n\n","category":"type"},{"location":"documentation/api_docs/#Plasmo.LinkConstraint","page":"API Documentation","title":"Plasmo.LinkConstraint","text":"LinkConstraint{F <: JuMP.AbstractJuMPScalar,S <: MOI.AbstractScalarSet} <: AbstractLinkConstraint\n\nType inherits JuMP.AbstractConstraint.  Contains a func and set used to describe coupling between optinodes.\n\nLinkConstraint(con::JuMP.ScalarConstraint)\n\nCreates a linking constraint from a JuMP.ScalarConstraint.\n\nLinkConstraint(ref::LinkConstraintRef)\n\nRetrieves a linking constraint from a LinkConstraintRef.\n\n\n\n\n\n","category":"type"},{"location":"documentation/api_docs/#Plasmo.LinkConstraintRef","page":"API Documentation","title":"Plasmo.LinkConstraintRef","text":"LinkConstraintRef\n\nA constraint reference to a linkconstraint. Stores linkconstraint id and the optiedge it belong to.\n\n\n\n\n\n","category":"type"},{"location":"documentation/api_docs/#Plasmo.attached_node","page":"API Documentation","title":"Plasmo.attached_node","text":"attached_node(con::LinkConstraint)\n\nRetrieve the attached node on linkconstraint con\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.set_attached_node","page":"API Documentation","title":"Plasmo.set_attached_node","text":"set_attached_node(con::LinkConstraint,node::OptiNode).\n\nSet the linkconstraint con to optinode node. Mostly useful for algorithms that need an \"owning\" node on a linkconstraint\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Extended-Functions","page":"API Documentation","title":"Extended Functions","text":"","category":"section"},{"location":"documentation/api_docs/","page":"API Documentation","title":"API Documentation","text":"JuMP.all_variables\nJuMP.set_optimizer\nJuMP.optimize!\nJuMP.objective_function\nJuMP.value\nJuMP.dual\nJuMP.num_variables\nJuMP.num_constraints\nJuMP.object_dictionary\nJuMP.add_variable\nJuMP.add_constraint\nJuMP.add_nonlinear_constraint\nJuMP.num_nonlinear_constraints\nJuMP.list_of_constraint_types\nJuMP.all_constraints\nJuMP.objective_value\nJuMP.objective_sense\nJuMP.set_objective\nJuMP.set_nonlinear_objective\nJuMP.set_objective_function\nJuMP.set_objective_sense\nJuMP.NLPEvaluator\nJuMP.termination_status","category":"page"},{"location":"documentation/api_docs/#JuMP.all_variables","page":"API Documentation","title":"JuMP.all_variables","text":"JuMP.all_variables(node::OptiNode)::Vector{JuMP.VariableRef}\n\nRetrieve all of the variables on the optinode node.\n\n\n\n\n\nJuMP.all_variables(graph::OptiGraph)::Vector{JuMP.VariableRef}\n\nRetrieve a list of all variables in optigraph graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.set_optimizer","page":"API Documentation","title":"JuMP.set_optimizer","text":"JuMP.set_optimizer(graph::OptiGraph, optimizer_constructor::Any)\n\nSet an MOI optimizer onto the optigraph graph.  Works exactly the same as using JuMP to set an optimizer.\n\nExample\n\ngraph = OptiGraph()\nset_optimizer(graph, GLPK.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.optimize!","page":"API Documentation","title":"JuMP.optimize!","text":"JuMP.optimize!(graph::OptiGraph)\n\nOptimize the optigraph graph with the current set optimizer\n\nExample\n\ngraph = OptiGraph()\nset_optimizer(graph, GLPK.Optimizer)\noptimize!(graph)\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.objective_function","page":"API Documentation","title":"JuMP.objective_function","text":"JuMP.objective_function(node::OptiNode)\n\nRetrieve the objective function on optinode node\n\n\n\n\n\nJuMP.objective_function(graph::OptiGraph)\n\nRetrieve the current graph objective function.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.value","page":"API Documentation","title":"JuMP.value","text":"JuMP.value(node::OptiNode, vref::VariableRef)\n\nGet the variable value of vref on the optinode node. This value is always the local node value, not the value the node variable takes when solved as part of a larger OptiGraph.\n\n\n\n\n\nJuMP.value(graph::OptiGraph, vref::VariableRef)\n\nGet the variable value of vref on the optigraph graph. This value corresponds to the optinode variable value obtained by solving graph which contains said optinode.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.dual","page":"API Documentation","title":"JuMP.dual","text":"JuMP.dual(c::JuMP.ConstraintRef{OptiNode,NonlinearConstraintIndex})\n\nGet the dual value on a nonlinear constraint on an OptiNode\n\n\n\n\n\nJuMP.dual(graph::OptiGraph, linkref::LinkConstraintRef)\n\nRetrieve the dual value of linkref on optigraph graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.num_variables","page":"API Documentation","title":"JuMP.num_variables","text":"JuMP.num_variables(node::OptiNode)\n\nGet the number of variables on optinode node\n\n\n\n\n\nJuMP.num_variables(graph::OptiGraph)::Int64\n\nRetrieve the number of local node variables in graph. Does not include variables in subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.num_constraints","page":"API Documentation","title":"JuMP.num_constraints","text":"JuMP.num_constraints(node::OptiNode)\n\nGet the number of constraints on optinode node\n\n\n\n\n\nJuMP.num_constraints(graph::OptiGraph)\n\nRetrieve the number of local node constraints in graph. Does not include constraints in subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.object_dictionary","page":"API Documentation","title":"JuMP.object_dictionary","text":"JuMP.object_dictionary(node::OptiNode)\n\nGet the underlying object dictionary of optinode node\n\n\n\n\n\nJuMP.object_dictionary(graph::OptiGraph)\n\nRetrieve the object dictionary of optigraph graph\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.add_variable","page":"API Documentation","title":"JuMP.add_variable","text":"JuMP.add_variable(node::OptiNode, v::JuMP.AbstractVariable, name::String=\"\")\n\nAdd variable v to optinode node. This function supports use of the @variable JuMP macro. Optionally add a base_name to the variable for printing.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.add_constraint","page":"API Documentation","title":"JuMP.add_constraint","text":"JuMP.add_constraint(node::OptiNode, con::JuMP.AbstractConstraint, base_name::String=\"\")\n\nAdd a constraint con to optinode node. This function supports use of the @constraint JuMP macro.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.add_nonlinear_constraint","page":"API Documentation","title":"JuMP.add_nonlinear_constraint","text":"JuMP.add_nonlinear_constraint(node::OptiNode, expr::Expr)\n\nAdd a non-linear constraint to an optinode using a Julia expression.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.num_nonlinear_constraints","page":"API Documentation","title":"JuMP.num_nonlinear_constraints","text":"JuMP.num_nonlinear_constraints(node::OptiNode)\n\nGet the number of nonlinear constraints on optinode node\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.list_of_constraint_types","page":"API Documentation","title":"JuMP.list_of_constraint_types","text":"JuMP.list_of_constraint_types(node::OptiNode)\n\nGet a list of constraint types on optinode node\n\n\n\n\n\nJuMP.list_of_constraint_types(graph::OptiGraph)\n\nRetrieve a list of the constraint types in optigraph graph\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.all_constraints","page":"API Documentation","title":"JuMP.all_constraints","text":"JuMP.all_constraints(node::OptiNode,F::DataType,S::DataType)\n\nGet all constraints on optinode node of function type F and set S\n\n\n\n\n\nJuMP.all_constraints(graph::OptiGraph, F::DataType, S::DataType)\n\nRetrieve a list of contraints with function type F and set S in optigraph graph\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.objective_value","page":"API Documentation","title":"JuMP.objective_value","text":"JuMP.objective_value(graph::OptiGraph)\n\nRetrieve the current objective value on optigraph graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.objective_sense","page":"API Documentation","title":"JuMP.objective_sense","text":"JuMP.objective_function(graph::OptiGraph)::MOI.OptimizationSense\n\nRetrieve the current graph objective sense.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.set_objective","page":"API Documentation","title":"JuMP.set_objective","text":"JuMP.set_objective(graph::OptiGraph, sense::MOI.OptimizationSense, func::JuMP.AbstractJuMPScalar)\n\nSet the objective of graph to the optimization sense and func.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.set_nonlinear_objective","page":"API Documentation","title":"JuMP.set_nonlinear_objective","text":"JuMP.set_nonlinear_objective(optinode::OptiNode, sense::MOI.OptimizationSense, obj::Any)\n\nSet a nonlinear objective on optinode node\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.set_objective_function","page":"API Documentation","title":"JuMP.set_objective_function","text":"JuMP.set_objective_function(graph::OptiGraph, x::JuMP.VariableRef)\n\nSet a single variable objective function on optigraph graph\n\nJuMP.set_objective_function(graph::OptiGraph, expr::JuMP.GenericAffExpr)\n\nSet an affine objective function on optigraph graph\n\nJuMP.set_objective_function(graph::OptiGraph, expr::JuMP.GenericQuadExpr)\n\nSet a quadratic objective function on optigraph graph\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.set_objective_sense","page":"API Documentation","title":"JuMP.set_objective_sense","text":"JuMP.set_objective_sense(graph::OptiGraph, sense::MOI.OptimizationSense)\n\nSet the current graph objective sense to sense.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.NLPEvaluator","page":"API Documentation","title":"JuMP.NLPEvaluator","text":"JuMP.NLPEvaluator(node::OptiNode)\n\nRetrieve the underlying JuMP NLP evaluator on optinode node\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#JuMP.termination_status","page":"API Documentation","title":"JuMP.termination_status","text":"JuMP.termination_status(node::OptiNode)\n\nReturn the termination status on optinode node\n\n\n\n\n\nJuMP.termination_status(graph::OptiGraph)\n\nRetrieve the current termination status of optigraph graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Graph-Processing-and-Partitioning","page":"API Documentation","title":"Graph Processing and Partitioning","text":"","category":"section"},{"location":"documentation/api_docs/","page":"API Documentation","title":"API Documentation","text":"Plasmo.graph_backend\nPlasmo.HyperGraph\nhyper_graph\nclique_graph\nedge_graph\nedge_hyper_graph\nbipartite_graph\nPartition\napply_partition!\naggregate\naggregate!\nall_neighbors\ninduced_subgraph\nPlasmo.incident_edges\nPlasmo.induced_edges\nPlasmo.identify_edges\nPlasmo.identify_nodes\nPlasmo.neighborhood\nexpand\nhierarchical_edges\nlinking_edges","category":"page"},{"location":"documentation/api_docs/#Plasmo.graph_backend","page":"API Documentation","title":"Plasmo.graph_backend","text":"graph_backend(graph::OptiGraph)\n\nRetrieve the underlying hypergraph backend of an optigraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.HyperGraph","page":"API Documentation","title":"Plasmo.HyperGraph","text":"HyperGraph\n\nA simple hypergraph type.  Contains attributes for vertices and hyperedges.\n\n\n\n\n\n","category":"type"},{"location":"documentation/api_docs/#Plasmo.hyper_graph","page":"API Documentation","title":"Plasmo.hyper_graph","text":"hyper_graph(graph::OptiGraph)\n\nRetrieve a hypergraph representation of the optigraph graph. Returns a HyperGraph object, as well as a dictionary that maps hypernodes and hyperedges to the original optinodes and optiedges.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#LightGraphs.SimpleGraphs.clique_graph","page":"API Documentation","title":"LightGraphs.SimpleGraphs.clique_graph","text":"clique_graph(graph::OptiGraph)\n\nRetrieve a standard graph representation of the optigraph graph. Returns a LightGraphs.Graph object, as well as a dictionary that maps vertices and edges to the optinodes and optiedges.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.edge_graph","page":"API Documentation","title":"Plasmo.edge_graph","text":"edge_graph(optigraph::OptiGraph)\n\nRetrieve the edge-graph representation of optigraph. This is sometimes called the line graph of a hypergraph. Returns a LightGraphs.Graph object, as well as a dictionary that maps vertices and edges to the optinodes and optiedges.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.edge_hyper_graph","page":"API Documentation","title":"Plasmo.edge_hyper_graph","text":"edge_hyper_graph(graph::OptiGraph)\n\nRetrieve an edge-hypergraph representation of the optigraph graph. Returns a HyperGraph object, as well as a dictionary that maps hypernodes and hyperedges to the original optinodes and optiedges. This is also called the dual-hypergraph representation of a hypergraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.bipartite_graph","page":"API Documentation","title":"Plasmo.bipartite_graph","text":"bipartite_graph(optigraph::OptiGraph)\n\nCreate a bipartite graph representation from optigraph.  The bipartite graph contains two sets of vertices corresponding to optinodes and optiedges respectively.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.Partition","page":"API Documentation","title":"Plasmo.Partition","text":"Partition(hypergraph::HyperGraph,node_membership_vector::Vector{Int64},ref_map::Dict)\n\nCreate a partition of optinodes using hypergraph, node_membership_vector, and 'refmap'.  The 'refmap' is a dictionary that maps hypernode indices (integers) and hyperedge indices (tuples) back to optinodes and optiedges.\n\nPartition(optigraph::OptiGraph,node_membership_vector::Vector{Int64},ref_map::Dict)\n\nCreate a partition using optigraph, node_membership_vector, and 'refmap'. The `refmap` is a mapping of node_indices to the original optinodes.\n\nPartition(optigraph::OptiGraph,optinode_vectors::Vector{Vector{OptiNode}})\n\nManually create a partition using optigraph and a vector of vectors containing sets of optinodes that represent each partition.\n\n\n\n\n\n","category":"type"},{"location":"documentation/api_docs/#Plasmo.apply_partition!","page":"API Documentation","title":"Plasmo.apply_partition!","text":"apply_partition!(optigraph::OptiGraph,partition::Partition)\n\nCreate subgraphs in optigraph using a partition.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.aggregate","page":"API Documentation","title":"Plasmo.aggregate","text":"aggregate(graph::OptiGraph)\n\nAggregate the optigraph graph into a new optinode.  Return an optinode and a dictionary which maps optinode variable and constraint references to the original optigraph.\n\naggregate(graph::OptiGraph,max_depth::Int64)\n\nAggregate the optigraph 'graph' into a new aggregated optigraph. Return a newly aggregated optigraph and a dictionary which maps new variables and constraints to the original optigraph. max_depth determines how many levels of subgraphs remain in the new aggregated optigraph. For example, a max_depth of 0 signifies there should be no subgraphs in the aggregated optigraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.aggregate!","page":"API Documentation","title":"Plasmo.aggregate!","text":"aggregate!(graph::OptiGraph, max_depth::Int64)\n\nAggregate graph by converting subgraphs into optinodes. The max_depth determines how many levels of subgraphs remain in the new aggregated optigraph. For example, a max_depth of 0 signifies there should be no subgraphs in the aggregated optigraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#LightGraphs.all_neighbors","page":"API Documentation","title":"LightGraphs.all_neighbors","text":"LightGraphs.all_neighbors(graph::OptiGraph, node::OptiNode)\n\nRetrieve the optinode neighbors of node in the optigraph graph.  Uses an underlying hypergraph to query for neighbors.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#LightGraphs.induced_subgraph","page":"API Documentation","title":"LightGraphs.induced_subgraph","text":"LightGraphs.induced_subgraph(graph::OptiGraph, nodes::Vector{OptiNode})\n\nCreate an induced subgraph of optigraph given a vector of optinodes.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.incident_edges","page":"API Documentation","title":"Plasmo.incident_edges","text":"incident_edges(hypergraph::HyperGraph,hypernode::HyperNode)\n\nIdentify the incident hyperedges to a HyperNode.\n\n\n\n\n\nincident_edges(hypergraph::HyperGraph,hypernodes::Vector{HyperNode})\n\nIdentify the incident hyperedges to a vector of HyperNodes.\n\n\n\n\n\nincident_edges(graph::OptiGraph, nodes::Vector{OptiNode})\n\nRetrieve incident edges to a set of optinodes.\n\nincident_edges(graph::OptiGraph, node::OptiNode)\n\nRetrieve incident edges to a single optinode.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.induced_edges","page":"API Documentation","title":"Plasmo.induced_edges","text":"induced_edges(hypergraph::HyperGraph,hypernodes::Vector{HyperNode})\n\nIdentify the induced hyperedges to a vector of HyperNodes.\n\nNOTE: This currently does not support hypergraphs with unconnected nodes\n\n\n\n\n\ninduced_edges(graph::OptiGraph, nodes::Vector{OptiNode})\n\nRetrieve induced edges to a set of optinodes.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.identify_edges","page":"API Documentation","title":"Plasmo.identify_edges","text":"identify_edges(hypergraph::HyperGraph,partitions::Vector{Vector{HyperNode}})\n\nIdentify both induced partition edges and cut edges given a partition of HyperNode vectors.\n\n\n\n\n\nidentify_edges(graph::OptiGraph, node_vectors::Vector{Vector{OptiNode}})\n\nIdentify induced edges and edge separators from a vector of optinode partitions.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.identify_nodes","page":"API Documentation","title":"Plasmo.identify_nodes","text":"identify_nodes(hypergraph::HyperGraph,partitions::Vector{Vector{HyperEdge}})\n\nIdentify both induced partition nodes and cut nodes given a partition of HyperEdge vectors.\n\n\n\n\n\nidentify_nodes(graph::OptiGraph, node_vectors::Vector{Vector{OptiEdge}})\n\nIdentify induced nodes and node separators from a vector of optiedge partitions.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.neighborhood","page":"API Documentation","title":"Plasmo.neighborhood","text":"neighborhood(g::HyperGraph,nodes::Vector{OptiNode},distance::Int64)\n\nRetrieve the neighborhood within distance of nodes.  Returns a vector of the original vertices and added vertices\n\n\n\n\n\nneighborhood(graph::OptiGraph, nodes::Vector{OptiNode}, distance::Int64)::Vector{OptiNode})\n\nReturn the optinodes within distance of the given nodes in the optigraph graph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.expand","page":"API Documentation","title":"Plasmo.expand","text":"expand(graph::OptiGraph, subgraph::OptiGraph, distance::Int64)\n\nReturn a new expanded subgraph given the optigraph graph and an existing subgraph subgraph. The returned subgraph contains the expanded neighborhood within distance of the given subgraph.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plasmo.hierarchical_edges","page":"API Documentation","title":"Plasmo.hierarchical_edges","text":"hierarchical_edges(graph::OptiGraph)::Vector{OptiEdge}\n\nQuery the edges in graph that connect its local nodes to nodes in its subgraphs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#Plotting","page":"API Documentation","title":"Plotting","text":"","category":"section"},{"location":"documentation/api_docs/","page":"API Documentation","title":"API Documentation","text":"PlasmoPlots.layout_plot\nPlasmoPlots.matrix_plot","category":"page"},{"location":"documentation/api_docs/#PlasmoPlots.layout_plot","page":"API Documentation","title":"PlasmoPlots.layout_plot","text":"PlasmoPlots.layout_plot(graph::OptiGraph; node_labels = false, subgraph_colors = false, node_colors = false, linewidth = 2.0,linealpha = 1.0, markersize = 30,labelsize = 20, markercolor = :grey,\nlayout_options = Dict(:tol => 0.01,:C => 2, :K => 4, :iterations => 2),\nplt_options = Dict(:legend => false,:framestyle => :box,:grid => false,:size => (800,800),:axis => nothing),\nline_options = Dict(:linecolor => :blue,:linewidth => linewidth,:linealpha => linealpha))\n\nPlot a graph layout of the optigraph graph. The following keyword arguments can be provided to customize the graph layout.\n\nnode_labels = false: whether to label nodes using the corresponding optinode label attribute.\nsubgraph_colors = false: whether to color nodes according to their subgraph.\nnode_colors = false: whether to color nodes.  Only active if subgraph_colors = false.\nlinewidth = 2.0: the linewidth attribute for each edge in graph.\nlinealpha = 1.0: the linealpha attribute for each edge in graph.\nmarkersize = 30: the markersize which determines the size of each node in graph.\nlabelsize = 20: the size for each node label.  Only active if node_labels = true.\nmarkercolor = :grey: the color for each node.\nlayout_options = Dict(:tol => 0.01,:C => 2, :K => 4, :iterations => 2): dictionary with options for the layout algorithm.\ntol: permitted distance between a current and calculated co-ordinate.\nC,K: scaling parameters.\niterations: number of iterations used to apply forces.\nplt_options = Dict(:legend => false,:framestyle => :box,:grid => false,:size => (800,800),:axis => nothing): dictionary with primary plotting options.\nlegend: whether to include legend, or legend position.\nframestyle: style of frame used for plot.\nsize: size of the resulting plot.\naxis: whether to include the axis.  The axis typically does not make sense for a graph layout plot.\nIt is also possible to use various plotting options compatible with Plots.scatter from the Plots.jl package.\nline_options = Dict(:linecolor => :blue,:linewidth => linewidth,:linealpha => linealpha): line plotting options used to display edges in the graph.\nlinecolor: color to use for each line.\nlinewidth: linewidth to use for each edge.  Defaults to the above option.\nlinealpha: linealpha to use for each edge. Default to the above option.\n\n\n\n\n\n","category":"function"},{"location":"documentation/api_docs/#PlasmoPlots.matrix_plot","page":"API Documentation","title":"PlasmoPlots.matrix_plot","text":"PlasmoPlots.matrix_plot(graph::OptiGraph;node_labels = false,labelsize = 24,subgraph_colors = false,node_colors = false,markersize = 1)\n\nPlot a matrix visualization of the optigraph: graph. The following keyword arguments can be provided to customize the matrix visual.\n\nnode_labels = false: whether to label nodes using the corresponding optinode label attribute.\nlabelsize: the size for each node label.  Only active if node_labels = true.\nsubgraph_colors = false: whether to color nodes according to their subgraph.\nnode_colors = false: whether to color nodes.  Only active if subgraph_colors = false.\nmarkersize = 1: Size of the linking constraints in the matrix representation.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Plasmo logo)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = Plasmo\nDocTestSetup = quote\n    using Plasmo\n    using GLPK\n    using PlasmoPlots\nend","category":"page"},{"location":"#Plasmo.jl-Platform-for-Scalable-Modeling-and-Optimization","page":"Introduction","title":"Plasmo.jl - Platform for Scalable Modeling and Optimization","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Plasmo.jl is a graph-based optimization framework written in Julia that builds upon the JuMP.jl modeling language to offer a modular style to construct and solve optimization problems. The package implements what is called an OptiGraph abstraction to create graph-structured optimization models and facilitate graph-based processing functions. An OptiGraph captures the underlying graph topology of an optimization problem using OptiNodes (which represent stand-alone self-contained optimization models) that are coupled by means of OptiEdges (which represent coupling constraints). The resulting topology can be used for tasks such as visualization, graph partitioning, and interfacing (and developing) decomposition-based solvers.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Plasmo.jl works for Julia versions 1.6 and later. From Julia, Plasmo.jl can be installed using the Pkg module:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"Plasmo\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or alternatively from the Julia package manager by performing the following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add Plasmo","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"documentation/quickstart.md\"\n    \"documentation/modeling.md\"\n    \"documentation/partitioning.md\"\n    \"documentation/solvers.md\"\n    \"documentation/api_docs.md\"\n    ]\nDepth = 2","category":"page"},{"location":"#Future-Development","page":"Introduction","title":"Future Development","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are currently a few major development avenues for Plasmo.jl. Here is a list of some of the major features we intend to add for future releases:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Parallel & Distributed modeling capabilities\nNonlinear linking constraints\nGraph metrics and custom partitioning algorithms\nBetter distributed solver support","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We are also looking for help from new contributors. If you would like to contribute to Plasmo.jl, please create a new issue or pull request on the GitHub page","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Citing-Plasmo.jl","page":"Introduction","title":"Citing Plasmo.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find Plasmo.jl useful for your work, you may cite the current pre-print:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@misc{JalvingShinZavala2020,\ntitle = {A Graph-Based Modeling Abstraction for Optimization: Concepts and Implementation in Plasmo.jl},\nauthor = {Jordan Jalving and Sungho Shin and Victor M. Zavala},\nyear = {2020},\neprint = {2006.05378},\narchivePrefix = {arXiv},\nprimaryClass = {math.OC}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There is also an earlier manuscript where we presented the initial ideas behind Plasmo.jl which you can find here:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{JalvingCaoZavala2019,\nauthor = {Jalving, Jordan and Cao, Yankai and Zavala, Victor M},\njournal = {Computers {\\&} Chemical Engineering},\npages = {134--154},\ntitle = {Graph-based modeling and simulation of complex systems},\nvolume = {125},\nyear = {2019},\ndoi = {https://doi.org/10.1016/j.compchemeng.2019.03.009}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A pre-print of this paper can also be found here","category":"page"},{"location":"documentation/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"This quickstart example gives a brief overview of the functions needed to effectively use Plasmo.jl to build optimization models. If you are familiar with JuMP.jl, much of the functionality you see here will be familiar. In fact, the primary OptiGraph and OptiNode objects from Plasmo.jl extend the JuMP.AbstractModel and support many JuMP functions.  ","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"The below example demonstrates the construction of a simple linear optimization problem that contains two optinodes coupled by a simple LinkConstraint (which creates an OptiEdge) which is solved with the GLPK linear optimization solver. Additional examples can be found at the Plasmo Examples repository.","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"Once Plasmo.jl has been installed, you can use it from a Julia session as following:","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using Plasmo","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"For this example we also need to import the GLPK optimization solver and the PlasmoPlots package which we use to visualize graph structure.","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> using GLPK\njulia> using PlasmoPlots","category":"page"},{"location":"documentation/quickstart/#Create-an-OptiGraph","page":"Quickstart","title":"Create an OptiGraph","text":"","category":"section"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"The following command will create the optigraph (referred to as graph). We also see the printed output which denotes the number of optinodes, optiedges, link-constraints, and subgraphs (other optigraphs contained within graph).","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> graph = OptiGraph()\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     0              (0)\n      OptiEdges:     0              (0)\nLinkConstraints:     0              (0)\n sub-OptiGraphs:     0              (0)","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nAn OptiGraph distinguishes between its direct elements (optinodes and optiedges contained directly within the graph) and its subgraph elements (optinodes and optiedges contained within its subgraphs). This distinction is used to describe hierarchical graph structures in Hierarchical Modeling using Subgraphs.","category":"page"},{"location":"documentation/quickstart/#Add-OptiNodes","page":"Quickstart","title":"Add OptiNodes","text":"","category":"section"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"An optigraph consists of OptiNodes which contain stand-alone optimization models. An optinode supports JuMP macros used to create variables, constraints, expressions, and objective functions (i.e. it supports JuMP macros such as @variable, @constraint, and @objective). The simplest way to add optinodes to an optigraph is to use the @optinode macro as shown in the following code snippet. For this example we create the optinode n1, we create two optinode variables x and y, and we add a single constraint and an objective function.","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> @optinode(graph, n1)\nOptiNode w/ 0 Variable(s) and 0 Constraint(s)\n\njulia> @variable(n1, y >= 2)\nn1[:y]\n\njulia> @variable(n1, x >= 0)\nn1[:x]\n\njulia> @constraint(n1, x + y >= 3)\nn1[:y] + n1[:x] ≥ 3.0\n\njulia> @objective(n1, Min, y)\nn1[:y]","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"DocTestSetup = nothing","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"    DocTestSetup = quote\n    using Plasmo\n    using GLPK\n    using PlasmoPlots\n\n    graph = OptiGraph()\n    @optinode(graph,n1)\n    @variable(n1, y >= 2)\n    @variable(n1,x >= 0)\n    @constraint(n1,x + y >= 3)\n    @objective(n1, Min, y)\n\n    @optinode(graph,n2);\n    @variable(n2, y >= 0);\n    @variable(n2, x >= 0);\n    @constraint(n2,x + y >= 3);\n    @objective(n2, Min, y);\n\n    @optinode(graph,n3);\n    @variable(n3, y >= 0);\n    @variable(n3,x >= 0);\n    @constraint(n3,x + y >= 3);\n    @objective(n3, Min, y);  \nend","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"We can create more optinodes and add variables, constraints, and objective functions to each of them.","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> @optinode(graph, n2);\njulia> @variable(n2, y >= 0);\njulia> @variable(n2, x >= 0);\njulia> @constraint(n2, x + y >= 3);\njulia> @objective(n2, Min, y);\n\njulia> @optinode(graph, n3);\njulia> @variable(n3, y >= 0);\njulia> @variable(n3, x >= 0);\njulia> @constraint(n3, x + y >= 3);\njulia> @objective(n3, Min, y);  ","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> println(graph)\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     3              (3)\n      OptiEdges:     0              (0)\nLinkConstraints:     0              (0)\n sub-OptiGraphs:     0              (0)","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"DocTestSetup = nothing","category":"page"},{"location":"documentation/quickstart/#Create-LinkConstraints","page":"Quickstart","title":"Create LinkConstraints","text":"","category":"section"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"A LinkConstraint can be used to couple variables between optinodes. Creating a link-constraint automatically creates an OptiEdge in the optigraph which describes the connectivity between optinodes.  Link-constraints are created using the @linkconstraint macro which takes the exact same input as the JuMP.@constraint macro. The following code creates a link-constraint between variables on the three optinodes.","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> @linkconstraint(graph, n1[:x] + n2[:x] + n3[:x] == 3)\n: n1[:x] + n2[:x] + n3[:x] = 3.0\n\njulia> println(graph)\n      OptiGraph: # elements (including subgraphs)\n-------------------------------------------------------------------\n      OptiNodes:     3              (3)\n      OptiEdges:     1              (1)\nLinkConstraints:     1              (1)\n sub-OptiGraphs:     0              (0)\n","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nUsing the standard @constraint macro on an optigraph will also create a link-constraint. The @linkconstraint syntax is preferred to help model readability.","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nNonlinear link-constraints are not yet supported.","category":"page"},{"location":"documentation/quickstart/#Solve-the-OptiGraph-and-Query-the-Solution","page":"Quickstart","title":"Solve the OptiGraph and Query the Solution","text":"","category":"section"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"When using a MathOptInterface.jl (MOI) optimization solver, we can optimize an optigraph using the set_optimizer and optimize! functions extended from JuMP.   Plasmo.jl will translate the optigraph into an MOI optimizer to solve the model.","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> set_optimizer(graph, GLPK.Optimizer)\n\njulia> optimize!(graph)","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"After returning from the optimizer we can query the termination status using termination_status (again just like in JuMP). We can also query the solution of variables using value and the objective value of the graph using objective_value","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"julia> termination_status(graph)   \nOPTIMAL::TerminationStatusCode = 1\n\njulia> value(n1[:x])    \n1.0\n\njulia> value(n2[:x])\n2.0\n\njulia> value(n3[:x])\n0.0\n\njulia> objective_value(graph)\n6.0","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nIt is also possible to optimize individual optinodes, or even optimize different optigraphs that share the same optinode. The latest optimization result is always accessible using value(variable). The results specific to an optinode or optigraph can be accessed with value(node, variable) (for optinodes) or value(graph, variable) (for optigraphs).","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nPlasmo.jl assumes the objective function of each optinode is added by default.  The objective function for an optigraph can be changed using the @objective macro on the optigraph itself. This will update the local objective function on each optinode.Nonlinear graph objective functions are not yet supported. Currently, the user must set nonlinear objective functions on each optinode which get added together.","category":"page"},{"location":"documentation/quickstart/#Visualize-the-Structure","page":"Quickstart","title":"Visualize the Structure","text":"","category":"section"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"    using Plasmo\n    using PlasmoPlots\n\n    graph = OptiGraph()\n    @optinode(graph,n1)\n    @variable(n1, y >= 2)\n    @variable(n1,x >= 0)\n    @constraint(n1,x + y >= 3)\n    @objective(n1, Min, y)\n\n    @optinode(graph,n2);\n    @variable(n2, y >= 0);\n    @variable(n2,x >= 0);\n    @constraint(n2,x + y >= 3);\n    @objective(n2, Min, y);\n\n    @optinode(graph,n3);\n    @variable(n3, y >= 0);\n    @variable(n3, x >= 0);\n    @constraint(n3,x + y >= 3);\n    @objective(n3, Min, y);  \n\n    @linkconstraint(graph, n1[:x] + n2[:x] + n3[:x] == 3);","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"Lastly, it is often useful to visualize the structure of an optigraph. The visualization can lead to insights about an optimization problem and understand its connectivity. Plasmo.jl uses PlasmoPlots.jl (which builds on Plots.jl and NetworkLayout.jl) to visualize the layout of an optigraph. The code here shows how to obtain the graph topology using PlasmoPlots.layout_plot and we plot the corresponding incidence matrix structure using PlasmoPlots.matrix_plot. Both of these functions can accept keyword arguments to customize their layout or appearance. The matrix visualization also encodes information on the number of variables and constraints in each optinode and optiedge. The left figure shows a standard graph visualization where we draw an edge between each pair of nodes if they share an edge, and the right figure shows the matrix representation where labeled blocks correspond to nodes and blue marks represent linking constraints that connect their variables. The node layout helps visualize the overall connectivity of the graph while the matrix layout helps visualize the size of nodes and edges.","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"plt_graph = PlasmoPlots.layout_plot(graph,\n            node_labels=true, markersize=30, labelsize=15, linewidth=4,\n            layout_options=Dict(:tol=>0.01, :iterations=>2),\n            plt_options=Dict(:legend=>false, :framestyle=>:box, :grid=>false,\n            :size=>(400,400), :axis=>nothing))\n\nplt_matrix = PlasmoPlots.matrix_plot(graph, node_labels=true, markersize=15)   ","category":"page"},{"location":"documentation/quickstart/","page":"Quickstart","title":"Quickstart","text":"(Image: graph_quickstart) (Image: matrix_quickstart)","category":"page"}]
}
