<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Plasmo.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="Plasmo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Plasmo.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quickstart-Example"><span>Quickstart Example</span></a></li><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Future-Development"><span>Future Development</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="documentation/modeling/">Modeling</a></li><li><a class="tocitem" href="documentation/partitioning/">Partitioning and Graph Operations</a></li><li><a class="tocitem" href="documentation/solvers/">Solvers</a></li><li><a class="tocitem" href="documentation/plotting/">Plotting</a></li><li><a class="tocitem" href="tutorials/tutorials/">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/zavalab/Plasmo.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p><img src="assets/plasmo.svg" alt="Plasmo logo"/></p><h1 id="Plasmo.jl-Platform-for-Scalable-Modeling-and-Optimization"><a class="docs-heading-anchor" href="#Plasmo.jl-Platform-for-Scalable-Modeling-and-Optimization">Plasmo.jl - Platform for Scalable Modeling and Optimization</a><a id="Plasmo.jl-Platform-for-Scalable-Modeling-and-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Plasmo.jl-Platform-for-Scalable-Modeling-and-Optimization" title="Permalink"></a></h1><p>Plasmo.jl is a graph-based optimization framework written in <a href="https://julialang.org">Julia</a> that adopts a modular modeling style to construct and solve optimization problems. The package builds upon the modeling framework <a href="https://github.com/jump-dev/JuMP.jl">JuMP.jl</a> to create graph-structured optimization models and works at a higher level of abstraction which facilitates hierarchical modeling and graph-based operations such as <a href="https://en.wikipedia.org/wiki/Graph_partition">partitioning</a>. More specifically, Plasmo.jl implements what is called the <code>OptiGraph</code> abstraction to construct optimization models. An <code>OptiGraph</code> captures the underlying topology of an optimization problem using <code>OptiNodes</code> (which represent stand-alone optimization models) that are coupled by means of <code>OptiEdges</code> (which correspond to coupling constraints). The resulting graph topology enables systematic model construction and can be exploited for various modeling tasks and the development of distributed optimization algorithms.  </p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The Plasmo.jl package works for Julia versions 1.0 and later. From Julia, Plasmo.jl can be installed using the built-in package manager:</p><pre><code class="language-julia">import Pkg
Pkg.add(&quot;Plasmo&quot;)</code></pre><p>or alternatively from the Julia 1.0 package manager, one can simply do:</p><pre><code class="language-none">] add Plasmo</code></pre><h2 id="Quickstart-Example"><a class="docs-heading-anchor" href="#Quickstart-Example">Quickstart Example</a><a id="Quickstart-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Quickstart-Example" title="Permalink"></a></h2><p>This quickstart example gives a brief overview of the functions needed to effectively use Plasmo.jl to build optimization models. If you are familiar with JuMP, much of the functionality you see here will be equivalent.  In fact, the primary <code>OptiGraph</code> object is an extension of the <code>JuMP.AbstractModel</code>, as well as its contained <code>OptiNodes</code>.  </p><p>The below example demonstrates the construction of a simple nonlinear optimization problem that contains two <code>OptiNodes</code> coupled by a simple <code>LinkConstraint</code> (which creates an <code>OptiEdge</code>) and solved with the linear optimization solver GLPK. More detailed examples can be found in the <a href="https://github.com/zavalab/Plasmo.jl/tree/master/examples">examples folder</a>.</p><p>Once Plasmo.jl has been installed, you can use it from a Julia session as following:</p><pre><code class="language-julia-repl">julia&gt; using Plasmo</code></pre><p>For this example we also need to import the GLPK optimization solver and the Plots package which we use to visualize graph structure.</p><pre><code class="language-julia">julia&gt; using GLPK
julia&gt; using Plots</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We highlight that it is possible to use any solver that works with JuMP. By default, when using a standard optimization solver available through JuMP, Plasmo.jl will aggregate the <code>OptiGraph</code> into a single node to solve (hence ignoring the graph structure).  While it is useful having such granular control to build optimization models with an <code>OptiGraph</code>, we note that this aggregation step introduces additional model-building time when using standard optimization solvers (such as GLPK and Ipopt).</p></div></div><h3 id="Create-an-OptiGraph"><a class="docs-heading-anchor" href="#Create-an-OptiGraph">Create an OptiGraph</a><a id="Create-an-OptiGraph-1"></a><a class="docs-heading-anchor-permalink" href="#Create-an-OptiGraph" title="Permalink"></a></h3><p>The following command will create an <code>OptiGraph</code> model.  We also see the printed output which denotes the number of optinodes, linking constraints, and subgraphs within the <code>OptiGraph</code>.</p><pre><code class="language-julia-repl">julia&gt; graph = OptiGraph()
OptiGraph:
local nodes: 0, total nodes: 0
local link constraints: 0, total link constraints 0
local subgraphs: 0, total subgraphs 0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An <code>OptiGraph</code> distinguishes between local and total entities (i.e. nodes, edges, link constraints, and subgraphs). This distinction between local and total is used to describe hierarchical graph structures which are introduced in <a href="documentation/modeling/#Hierarchical-Modeling">Hierarchical Modeling</a>.</p></div></div><h3 id="Add-OptiNodes"><a class="docs-heading-anchor" href="#Add-OptiNodes">Add OptiNodes</a><a id="Add-OptiNodes-1"></a><a class="docs-heading-anchor-permalink" href="#Add-OptiNodes" title="Permalink"></a></h3><p>An <code>OptiGraph</code> consists of <code>OptiNodes</code> which contain stand-alone optimization models. An <code>OptiNode</code> extends a <code>JuMP.AbstractModel</code> (and also a wraps a <code>JuMP.Model</code>) and supports the same macros to create variables, constraints, and add objective functions (using <code>@variable</code>, <code>@constraint</code>, and <code>@objective</code>).  To add optinodes to a graph, one can simply use the <code>@optinode</code> macro as shown in the following code snippet. For this example, we create the <code>OptiNode</code> <code>n1</code>, we create two variables <code>x</code> and <code>y</code>, and add a single constraint and an objective function.</p><pre><code class="language-jldocest">julia&gt; @optinode(graph,n1)
OptiNode w/ 0 Variable(s)

julia&gt; @variable(n1, y &gt;= 2)
y

julia&gt; @variable(n1, x &gt;= 0)
x

julia&gt; @constraint(n1,x + y &gt;= 3)
x + y &gt;= 3

julia&gt; @objective(n1, Min, y)
y</code></pre><p>We can create more <code>OptiNodes</code> and add variables, constraints, and objective functions to each node in the graph.</p><pre><code class="language-julia">julia&gt; @optinode(graph,n2);
julia&gt; @variable(n2, y &gt;= 0);
julia&gt; @variable(n2,x &gt;= 0);
julia&gt; @constraint(n2,x + y &gt;= 3);
julia&gt; @objective(n2, Min, y);

julia&gt; @optinode(graph,n3);
julia&gt; @variable(n3, y &gt;= 0);
julia&gt; @variable(n3,x &gt;= 0);
julia&gt; @constraint(n3,x + y &gt;= 3);
julia&gt; @objective(n3, Min, y);  </code></pre><pre><code class="language-julia-repl">julia&gt; println(graph)
OptiGraph:
local nodes: 3, total nodes: 3
local link constraints: 0, total link constraints 0
local subgraphs: 0, total subgraphs 0</code></pre><h3 id="Create-LinkConstraints-(OptiEdges)"><a class="docs-heading-anchor" href="#Create-LinkConstraints-(OptiEdges)">Create LinkConstraints (OptiEdges)</a><a id="Create-LinkConstraints-(OptiEdges)-1"></a><a class="docs-heading-anchor-permalink" href="#Create-LinkConstraints-(OptiEdges)" title="Permalink"></a></h3><p>Linking constraints can be used to couple variables between optinodes.  Beneath the modeling surface, creating a linking constraint induces an <code>OptiEdge</code> in the <code>OptiGraph</code> which describes its connectivity.  Linking constraints are created using the <code>@linkconstraint</code> macro which takes the exact same input as the <code>JuMP.@constraint</code> macro.  The following code creates a linking constraint between variables on the three optinodes.</p><pre><code class="language-julia-repl">julia&gt; @linkconstraint(graph, n1[:x] + n2[:x] + n3[:x] == 3)
LinkConstraintRef(1, OptiEdge w/ 1 Constraint(s))

julia&gt; println(graph)
OptiGraph:
local nodes: 3, total nodes: 3
local link constraints: 1, total link constraints 1
local subgraphs: 0, total subgraphs 0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Nonlinear linking constraints are not yet supported</p></div></div><h3 id="Solve-and-Query-Solution"><a class="docs-heading-anchor" href="#Solve-and-Query-Solution">Solve and Query Solution</a><a id="Solve-and-Query-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-and-Query-Solution" title="Permalink"></a></h3><p>When using a JuMP/MOI enabled optimization solver, we can optimize an <code>OptiGraph</code> using the <code>optimize!</code> function extended from JuMP.   As mentioned earlier, Plasmo.jl aggregates the graph into a single model (an optinode), hands off the problem to JuMP and the chosen solver, and then populates the <code>OptiGraph</code> solution.</p><pre><code class="language-julia-repl">julia&gt; optimize!(graph,GLPK.Optimizer)
Converting OptiGraph to OptiNode...
Optimizing OptiNode
Found Solution</code></pre><p>After finding a solution, we can query it using <code>value(::OptiNode,::VariableRef)</code> extended from JuMP.   We can also query the objective value of the graph using <code>objective_value(::OptiGraph)</code></p><pre><code class="language-julia-repl">julia&gt; value(n1,n1[:x])    
1.0

julia&gt; value(n2,n2[:x])
2.0

julia&gt; value(n3,n3[:x])
0.0

julia&gt; objective_value(graph)
6.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Plasmo.jl assumes the objective function of each optinode is added by default.  The objective function for an optigraph can be changed using the <code>@objective</code> macro on the optigraph itself.</p></div></div><h3 id="Visualize-the-Structure"><a class="docs-heading-anchor" href="#Visualize-the-Structure">Visualize the Structure</a><a id="Visualize-the-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-the-Structure" title="Permalink"></a></h3><p>Lastly, it is often useful to be able to visualize the structure of an <code>OptiGraph</code> object.  Doing such a visualization can lead to physical insights about an optimization problem (such as space-time dependencies), but it is also helpful just to see the connectivity of the problem.  Plasmo.jl uses <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> and <a href="https://github.com/JuliaGraphs/NetworkLayout.jl">NetworkLayout.jl</a> to visualize the layout of an <code>OptiGraph</code>.  The code here shows how to obtain the graph topology using <code>Plots.plot(::OptiGraph)</code> and we plot the underlying adjacency matrix structure using <code>Plots.spy</code> function. Both of these functions can accept keyword arguments to customize their layout or appearance. The matrix visualization also encodes information on the number of variables and constraints in each node and edge. The left figure shows a standard graph visualization where we draw an edge between each pair of nodes if they share an edge, and the rightfigure shows the matrix representation where labeled blocks correspond to nodes and blue marks represent linking constraints that connect their variables. The node layout helps visualize the overall connectivity of the graph while the matrix layout helps visualize the size of nodes and edges.</p><pre><code class="language-julia-repl">julia&gt; plt_graph = Plots.plot(graph,node_labels = true, markersize = 30,labelsize = 15, linewidth = 4,layout_options = Dict(:tol =&gt; 0.01,:iterations =&gt; 2),plt_options = Dict(:legend =&gt; false,:framestyle =&gt; :box,:grid =&gt; false,:size =&gt; (400,400),:axis =&gt; nothing));

julia&gt; Plots.savefig(plt_graph,&quot;graph_layout.svg&quot;);

julia&gt; plt_matrix = Plots.spy(graph,node_labels = true,markersize = 15);

julia&gt; Plots.savefig(plt_matrix,&quot;matrix_layout.svg&quot;);</code></pre><img src="graph_layout.svg" alt="graph" width="400"/><img src="matrix_layout.svg" alt="matrix" width="400"/><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="documentation/modeling/#Modeling">Modeling</a></li><ul><li><a href="documentation/modeling/#Creating-an-OptiGraph">Creating an OptiGraph</a></li><li><a href="documentation/modeling/#Adding-OptiNodes">Adding OptiNodes</a></li><li><a href="documentation/modeling/#Adding-Linking-Constraints-(OptiEdges)">Adding Linking Constraints (OptiEdges)</a></li><li><a href="documentation/modeling/#Hierarchical-Modeling">Hierarchical Modeling</a></li><li><a href="documentation/modeling/#Query-OptiGraph-Attributes">Query OptiGraph Attributes</a></li><li><a href="documentation/modeling/#Methods">Methods</a></li></ul><li><a href="documentation/partitioning/#Partitioning-and-Graph-Operations">Partitioning and Graph Operations</a></li><ul><li><a href="documentation/partitioning/#Example-Problem:-Dynamic-Optimization">Example Problem: Dynamic Optimization</a></li><li><a href="documentation/partitioning/#Partitioning-OptiGraphs">Partitioning OptiGraphs</a></li><li><a href="documentation/partitioning/#Aggregating-OptiGraphs">Aggregating OptiGraphs</a></li><li><a href="documentation/partitioning/#Methods">Methods</a></li></ul><li><a href="documentation/solvers/#Solvers">Solvers</a></li><ul><li><a href="documentation/solvers/#JuMP/MOI-Solvers">JuMP/MOI Solvers</a></li><li><a href="documentation/solvers/#PipsSolver">PipsSolver</a></li><li><a href="documentation/solvers/#SchwarzSolver">SchwarzSolver</a></li></ul><li><a href="documentation/plotting/#Plotting">Plotting</a></li></ul><h2 id="Future-Development"><a class="docs-heading-anchor" href="#Future-Development">Future Development</a><a id="Future-Development-1"></a><a class="docs-heading-anchor-permalink" href="#Future-Development" title="Permalink"></a></h2><p>There are currently a few major development avenues for <code>Plasmo.jl</code>. Here is a list of some of the major features we intend to add for future releases:</p><ul><li>Parallel modeling capabilities</li><li>Nonlinear linking constraints</li><li>Graph metrics and custom partitioning algorithms</li><li>More distributed solver support</li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="documentation/partitioning/#Plasmo.HyperGraph"><code>Plasmo.HyperGraph</code></a></li><li><a href="documentation/modeling/#Plasmo.LinkConstraint"><code>Plasmo.LinkConstraint</code></a></li><li><a href="documentation/modeling/#Plasmo.OptiEdge"><code>Plasmo.OptiEdge</code></a></li><li><a href="documentation/modeling/#Plasmo.OptiGraph"><code>Plasmo.OptiGraph</code></a></li><li><a href="documentation/modeling/#Plasmo.OptiNode"><code>Plasmo.OptiNode</code></a></li><li><a href="documentation/partitioning/#Plasmo.Partition"><code>Plasmo.Partition</code></a></li><li><a href="documentation/modeling/#Base.getindex-Tuple{OptiGraph,OptiEdge}"><code>Base.getindex</code></a></li><li><a href="documentation/modeling/#Base.getindex-Tuple{OptiGraph,OptiNode}"><code>Base.getindex</code></a></li><li><a href="documentation/modeling/#JuMP.all_variables-Tuple{OptiNode}"><code>JuMP.all_variables</code></a></li><li><a href="documentation/modeling/#JuMP.num_constraints-Tuple{OptiGraph}"><code>JuMP.num_constraints</code></a></li><li><a href="documentation/modeling/#JuMP.num_variables-Tuple{OptiGraph}"><code>JuMP.num_variables</code></a></li><li><a href="documentation/modeling/#JuMP.objective_function-Tuple{OptiGraph}"><code>JuMP.objective_function</code></a></li><li><a href="documentation/modeling/#JuMP.set_optimizer-Tuple{OptiGraph,Any}"><code>JuMP.set_optimizer</code></a></li><li><a href="documentation/modeling/#JuMP.value-Tuple{OptiNode,VariableRef}"><code>JuMP.value</code></a></li><li><a href="documentation/modeling/#Plasmo.add_node!"><code>Plasmo.add_node!</code></a></li><li><a href="documentation/modeling/#Plasmo.add_subgraph!"><code>Plasmo.add_subgraph!</code></a></li><li><a href="documentation/partitioning/#Plasmo.aggregate"><code>Plasmo.aggregate</code></a></li><li><a href="documentation/modeling/#Plasmo.all_edges"><code>Plasmo.all_edges</code></a></li><li><a href="documentation/modeling/#Plasmo.all_linkconstraints"><code>Plasmo.all_linkconstraints</code></a></li><li><a href="documentation/modeling/#Plasmo.all_nodes"><code>Plasmo.all_nodes</code></a></li><li><a href="documentation/modeling/#Plasmo.all_subgraphs"><code>Plasmo.all_subgraphs</code></a></li><li><a href="documentation/partitioning/#Plasmo.expand"><code>Plasmo.expand</code></a></li><li><a href="documentation/modeling/#Plasmo.find_node"><code>Plasmo.find_node</code></a></li><li><a href="documentation/modeling/#Plasmo.getedge"><code>Plasmo.getedge</code></a></li><li><a href="documentation/modeling/#Plasmo.getedges"><code>Plasmo.getedges</code></a></li><li><a href="documentation/partitioning/#Plasmo.gethypergraph"><code>Plasmo.gethypergraph</code></a></li><li><a href="documentation/modeling/#Plasmo.getlinkconstraints"><code>Plasmo.getlinkconstraints</code></a></li><li><a href="documentation/modeling/#Plasmo.getnode"><code>Plasmo.getnode</code></a></li><li><a href="documentation/modeling/#Plasmo.getnodes"><code>Plasmo.getnodes</code></a></li><li><a href="documentation/modeling/#Plasmo.getsubgraphs"><code>Plasmo.getsubgraphs</code></a></li><li><a href="documentation/modeling/#Plasmo.is_node_variable"><code>Plasmo.is_node_variable</code></a></li><li><a href="documentation/partitioning/#Plasmo.make_subgraphs!"><code>Plasmo.make_subgraphs!</code></a></li><li><a href="documentation/partitioning/#Plasmo.neighborhood"><code>Plasmo.neighborhood</code></a></li><li><a href="documentation/modeling/#Plasmo.nodevalue"><code>Plasmo.nodevalue</code></a></li><li><a href="documentation/modeling/#Plasmo.set_model"><code>Plasmo.set_model</code></a></li><li><a href="documentation/plotting/#Plots.spy-Tuple{OptiGraph}"><code>Plots.spy</code></a></li><li><a href="documentation/plotting/#RecipesBase.plot-Tuple{OptiGraph}"><code>RecipesBase.plot</code></a></li><li><a href="documentation/modeling/#Plasmo.@NLnodeconstraint"><code>Plasmo.@NLnodeconstraint</code></a></li><li><a href="documentation/modeling/#Plasmo.@linkconstraint"><code>Plasmo.@linkconstraint</code></a></li><li><a href="documentation/modeling/#Plasmo.@optinode"><code>Plasmo.@optinode</code></a></li></ul><h3 id="Citing-Plasmo.jl"><a class="docs-heading-anchor" href="#Citing-Plasmo.jl">Citing Plasmo.jl</a><a id="Citing-Plasmo.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Citing-Plasmo.jl" title="Permalink"></a></h3><p>If you find Plasmo.jl useful for your work, you may cite the current <a href="https://arxiv.org/abs/2006.05378">pre-print</a>:</p><pre><code class="language-sourceCode">@misc{JalvingShinZavala2020,
title = {A Graph-Based Modeling Abstraction for Optimization: Concepts and Implementation in Plasmo.jl},
author = {Jordan Jalving and Sungho Shin and Victor M. Zavala},
year = {2020},
eprint = {2006.05378},
archivePrefix = {arXiv},
primaryClass = {math.OC}
}</code></pre><p>There is also an earlier manuscript where we presented the initial ideas behind Plasmo.jl which you can find <a href="https://www.sciencedirect.com/science/article/abs/pii/S0098135418312687">here</a>:</p><pre><code class="language-sourceCode">@article{JalvingCaoZavala2019,
author = {Jalving, Jordan and Cao, Yankai and Zavala, Victor M},
journal = {Computers {\&amp;} Chemical Engineering},
pages = {134--154},
title = {Graph-based modeling and simulation of complex systems},
volume = {125},
year = {2019},
doi = {https://doi.org/10.1016/j.compchemeng.2019.03.009}
}</code></pre><p>A pre-print of this paper can also be found <a href="https://arxiv.org/abs/1812.04983">here</a></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="documentation/modeling/">Modeling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 12 September 2020 03:09">Saturday 12 September 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
