<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multi-Horizon Model Predictive Control · Plasmo.jl</title><meta name="title" content="Multi-Horizon Model Predictive Control · Plasmo.jl"/><meta property="og:title" content="Multi-Horizon Model Predictive Control · Plasmo.jl"/><meta property="twitter:title" content="Multi-Horizon Model Predictive Control · Plasmo.jl"/><meta name="description" content="Documentation for Plasmo.jl."/><meta property="og:description" content="Documentation for Plasmo.jl."/><meta property="twitter:description" content="Documentation for Plasmo.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Plasmo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Plasmo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../documentation/quickstart/">Quickstart</a></li><li><a class="tocitem" href="../../documentation/modeling/">Modeling with OptiGraphs</a></li><li><a class="tocitem" href="../../documentation/graph_processing/">Graph Processing and Analysis</a></li><li><a class="tocitem" href="../../documentation/api_docs/">API Documentation</a></li><li><span class="tocitem">Distributed Memory</span><ul><li><a class="tocitem" href="../../documentation/distributed/">Introduction</a></li><li><a class="tocitem" href="../../documentation/distributed_quickstart/">Quickstart</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../supply_chain/">Supply Chain Optimization</a></li><li class="is-active"><a class="tocitem" href>Multi-Horizon Model Predictive Control</a><ul class="internal"><li><a class="tocitem" href="#Mathematical-Formulation"><span>Mathematical Formulation</span></a></li><li><a class="tocitem" href="#Modeling-in-Plasmo"><span>Modeling in Plasmo</span></a></li></ul></li><li><a class="tocitem" href="../quadcopter/">Optimal Control of a Quadcopter</a></li><li><a class="tocitem" href="../HVAC/">Hierarchical HVAC Optimization</a></li><li><a class="tocitem" href="../gas_pipeline/">Optimal Control of a Natural Gas Network</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Multi-Horizon Model Predictive Control</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multi-Horizon Model Predictive Control</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/plasmo-dev/Plasmo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/plasmo-dev/Plasmo.jl/blob/main/docs/src/tutorials/MHMPC.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multi-horizon-Model-Predictive-Control"><a class="docs-heading-anchor" href="#Multi-horizon-Model-Predictive-Control">Multi-horizon Model Predictive Control</a><a id="Multi-horizon-Model-Predictive-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-horizon-Model-Predictive-Control" title="Permalink"></a></h1><p>By: Kiernan Jennings</p><p>This tutorial is an introduction to formulation in the graph-based modelling framework Plasmo.jl (Platform for Scalable Modeling and Optimization) for beginners in optimization.</p><h2 id="Mathematical-Formulation"><a class="docs-heading-anchor" href="#Mathematical-Formulation">Mathematical Formulation</a><a id="Mathematical-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Formulation" title="Permalink"></a></h2><p>The following problem comes from Behrunani, Heer, Smith, and Lygeros (Behrunani, V., Heer, P., Smith, R., &amp; Lygeros, J. (2024). Recursive feasibility guarantees in multi-horizon MPC. 6 p. https://doi.org/10.3929/ETHZ-B-000707918)</p><p>Model Predictive Control (MPC) is a well-established method for optimal control of constrained systems. It relies on a dynamic model and real-time feedback to continuously optimize control inputs by predicting future system responses. However, a key limitation of traditional MPC is its fixed prediction horizon, which may not adequately balance short-term and long-term decision-making.</p><p>Multi-Horizon Model Predictive Control (MH-MPC) addresses this limitation by dividing the prediction horizon into multiple sub-intervals, each with a different sampling time. This approach optimizes control over both short and long time horizons, ensuring that immediate decisions align with long-term objectives.</p><p>In this problem, MH-MPC is applied to a linear mass-spring-damper system, demonstrating its effectiveness in handling dynamic control tasks. </p><p><img src="../../assets/spring_mass_damper.png" alt="room_figure"/> </p><p>Figure taken from Behrunani, et al.</p><p>This problem includes the following sets:</p><ul><li>State variables at time <span>$k$</span> (<span>$x_k$</span>)</li><li>Input variables at time <span>$k$</span> (<span>$u_k$</span>)</li><li>State cost matrices (<span>$Q_i$</span>)</li><li>Input cost matrices (<span>$R_i$</span>)</li><li>System cost matrices (<span>$A_i, B_i$</span>)</li></ul><p>Each sub-interval of MH-MPC is labeled using <span>$i \in H$</span>. The cost matrices are defined for each sub-interval. Let <span>$\mathbb{K}$</span> be the set of all time steps <span>$k$</span> within each sub-interval <span>$i$</span> and <span>$N_i$</span> be the cardinality of set <span>$\mathbb{K}_i$</span>. Also, the control invariant set <span>$\mathbb{X}_{CI} \subseteq \mathbb{X}$</span>.</p><p>An important distinction for MH-MPC is the dual time horizon that is used in the optimization problem. This is encapsulated in a time horizon uses a diffusing-horizon (available here: https://ieeexplore.ieee.org/document/9658150). To define these time steps in the MH-MPC problem, the sampling time of the <span>$i^\text{th}$</span> sub-interval is <span>$t_i = \alpha_i t_1 (\alpha_1 = 1)$</span> where <span>$\alpha_i \in \mathbb{Z}_{\geq1}$</span> and increasing such that <span>$\alpha_1 \lt \alpha_2 \lt ... \lt \alpha_{H-1} \lt \alpha_{H}$</span>. Visually, this is described below.</p><p><img src="../../assets/behrunani_mhmpc.png" alt="room_figure"/>  Figure taken from Behrunani et al.</p><p>The MH-MPC optimization problem can be written as:</p><p class="math-container">\[\begin{aligned}
    \min_{\{ x_k, u_k\}^N_{k=0}} \quad &amp; \sum_{i \in \mathbb{H}} \left( \sum_{k \in \mathbb{K}_i} \left( x_k^\intercal Q_i x_k + u_k^\intercal R_i u_k \right) \right) + x_N^\intercal Q_H x_N\\
    \textrm{s.t.} \quad &amp; x_{k+1} = A_i x_k + B_i u_k, \quad\forall k \in \mathbb{K}_i, \forall i \in \mathbb{H} \\
    &amp; x_k \in \mathbb{X}, \forall k \in \mathbb{Z}_{0:N} \\
    &amp; u_k \in \mathbb{U}, \forall k \in \mathbb{Z}_{0:N-1} \\
    &amp; x_N \in \mathbb{X}_{CI}
\end{aligned}\]</p><h2 id="Modeling-in-Plasmo"><a class="docs-heading-anchor" href="#Modeling-in-Plasmo">Modeling in Plasmo</a><a id="Modeling-in-Plasmo-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-in-Plasmo" title="Permalink"></a></h2><p>The general idea is to use a graph-based approach to model the sub-intervals as sub-graphs with each node is a specific time point. This will all be encapsulated under one master graph. This implementation is shown below.</p><p><img src="../../assets/PlasmoGraphic.svg" alt="room_figure"/> </p><h3 id="1.-Import-packages-and-define-constants"><a class="docs-heading-anchor" href="#1.-Import-packages-and-define-constants">1. Import packages and define constants</a><a id="1.-Import-packages-and-define-constants-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Import-packages-and-define-constants" title="Permalink"></a></h3><p>This section serves to define the constants given for the problem statement and import the necessary packages to be used in this program. <span>$Ipopt$</span> is used as a nonlinear programming solver. </p><pre><code class="language-julia hljs">using Plasmo
using Ipopt

# Constants given:
m = 0.5 # kg
k = 0.5 # N/m (spring constant)
b = 0.25 # Ns/m (damping constant)

t_i = [0.05;0.1;0.2;0.4;0.8] # Discretization for each sub-interval
N_i = [4;6;4;4;2] # Cardinality of K_i
T_i = [0.2;0.6;0.8;1.6;1.6] # Total time spanned by each sub-interval
K_i = [[0,3];[4,9];[10,13];[14,17];[18,19]] # Set of all time steps k in each sub-interval (excludes termination)

R = Diagonal([1.0])  # input cost matrix 
Q = Diagonal([1.0, 1.0])

NX = 2 # Number of x variables [position, velocity]
NU = 1 # Number of u variables [force]</code></pre><h3 id="2.-Make-graph-structure"><a class="docs-heading-anchor" href="#2.-Make-graph-structure">2. Make graph structure</a><a id="2.-Make-graph-structure-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Make-graph-structure" title="Permalink"></a></h3><p>We define our graph and subgraph structure. This encapsulates the MH-MPC approach for each <span>$H$</span> sub-interval  <span>$i \in H$</span>. Here <span>$H = 5$</span>. To run the entire optimization over a set time period, we will wrap the model construction and optimization (steps 2 through 5) in a function called <span>$MHMPC$</span>.</p><pre><code class="language-julia hljs">function add_horizon_subgraphs()
    # All of the subgraphs
    graph_SG1 = OptiGraph()
    graph_SG2 = OptiGraph()
    graph_SG3 = OptiGraph()
    graph_SG4 = OptiGraph()
    graph_SG5 = OptiGraph()
    
    subgraphs_all = [graph_SG1, graph_SG2, graph_SG3, graph_SG4, graph_SG5]
    
    # Initialize all nodes for subgraphs
    @optinode(graph_SG1, nodes1[1:N_i[1]])
    @optinode(graph_SG2, nodes2[1:N_i[2]])
    @optinode(graph_SG3, nodes3[1:N_i[3]])
    @optinode(graph_SG4, nodes4[1:N_i[4]])
    @optinode(graph_SG5, nodes5[1:N_i[5]])
    
    nodes_all = [graph_SG1[:nodes1], graph_SG2[:nodes2], graph_SG3[:nodes3], graph_SG4[:nodes4], graph_SG5[:nodes5]]
    return subgraphs_all, nodes_all
end</code></pre><p>The second parameter of <span>$@optinode$</span> will initialize <span>$N_i$</span> nodes. They can be referenced (as seen later) by calling the name and the subsequent index of that specific node (e.g. <span>$nodes2[1]$</span> for the first node of the second subgraph.). The arrays <span>$subgraphs_all$</span> and <span>$nodes_all$</span> are used for easier, ordered indexing.</p><h3 id="3.-Initialize-variables-for-each-node"><a class="docs-heading-anchor" href="#3.-Initialize-variables-for-each-node">3. Initialize variables for each node</a><a id="3.-Initialize-variables-for-each-node-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Initialize-variables-for-each-node" title="Permalink"></a></h3><p>This step is necessary for initializing the state and input variables. Recall, each node is representative of a time point in the MH-MPC problem. <span>$@variable$</span> is a macro to initialize a variable for the specific node in the first parameter. The constraints for <span>$x$</span> and <span>$u$</span> are implemented using the inequality constraints seen in the second parameter. Additionally, the vector notation for <span>$x,u$</span> will initialize each variable as a vector of size <span>$NX, NU$</span>, respectively.</p><p><span>$@expression$</span> is another macro that defines a specific symbolic expression for each node. This expression will add simplifications for the following code representative of the first equality constraint: <span>$x_{k+1} = A_k x_k + B_k x_k$</span>. This expression is named via the second parameter.</p><p>Additionally, the initial condition for this problem is defined for <span>$t=0$</span>, where <span>$x_0 = [18\quad \mathord{-} 14]$</span>. The <span>$fix$</span> function will fix a specified variable.</p><pre><code class="language-julia hljs">function add_variables!(subgraphs_all, t_i, x0)
    for (subgraph, t_step) in zip(subgraphs_all, t_i)
        # Instantiate x,u for each node (time point)
        for node in all_nodes(subgraph)
            @variable(node, -20 &lt;= x[1:NX] &lt;= 20)
            @variable(node, -0.5 &lt;= u[1:NU]&lt;= 0.5)
    
            @variable(node, dt == t_step)
    
            A = [1 dt; -dt (1-dt/2)]
            B = [0 ; 2*dt]
    
            @expression(node, Ax_Bu[i = 1:NX],  A[i, 1] * node[:x][1] + A[i, 2] * node[:x][2] + B[i] * node[:u][1])
        end
    end

    # Set initial condition for t1
    fix.(subgraphs_all[1][:nodes1][1][:x][1], x0[1]; force=true)
    fix.(subgraphs_all[1][:nodes1][1][:x][2], x0[2]; force=true)
end</code></pre><h3 id="4.-Adding-linking-constraints"><a class="docs-heading-anchor" href="#4.-Adding-linking-constraints">4. Adding linking constraints</a><a id="4.-Adding-linking-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Adding-linking-constraints" title="Permalink"></a></h3><p>A linking constraint (<code>@linkconstraint</code>) is necessary for connectivity between nodes. In this case, the next time point in a sub-graph must be connected using the equality constraint mentioned prior. Here, we are equating <span>$x$</span> for the future time point to the <code>@expression</code> of the current time point, defined in step 3.</p><p>An important tip for using the <code>@linkconstraint</code> macro is using the loop in the second parameter to loop through a variable (<span>$j$</span> in this case).</p><p>In order to connect nodes between the subgraphs, you must reference the <code>graph_master</code> due to the scope of the variables. <code>graph_master</code> has access to all variables from all subgraphs, after all subgraphs were added  to the master graph. The <code>@linkconstraint</code> structure here is the same as connecting between individual subgraphs; taking the expression from the last node in the subgraph then setting it equal to the first <span>$x$</span> value of the next node.</p><pre><code class="language-julia hljs">function add_constraints!(graph_master, subgraphs_all, nodes_all)
    # Adding linking constraints between nodes in individual SG&#39;s
    for (subgraph, cardinality, node) in zip(subgraphs_all, N_i, nodes_all)   
        @linkconstraint(subgraph, [j = 1:(cardinality-1)], node[j+1][:x][1] == node[j][:Ax_Bu][1])
        @linkconstraint(subgraph, [j = 1:(cardinality-1)], node[j+1][:x][2] == node[j][:Ax_Bu][2])
    end

    # Add subgraphs to master graph
    for subgraph in subgraphs_all
        add_subgraph(graph_master, subgraph)
    end
    
    # Add linking constraint between subgraphs
    @linkconstraint(graph_master, [n = 1:(length(subgraphs_all)-1)], nodes_all[n+1][1][:x][1] == nodes_all[n][N_i[n]][:Ax_Bu][1])
    @linkconstraint(graph_master, [n = 1:(length(subgraphs_all)-1)], nodes_all[n+1][1][:x][2] == nodes_all[n][N_i[n]][:Ax_Bu][2])
end</code></pre><h3 id="5.-Setting-objective-and-running-optimization"><a class="docs-heading-anchor" href="#5.-Setting-objective-and-running-optimization">5. Setting objective and running optimization</a><a id="5.-Setting-objective-and-running-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Setting-objective-and-running-optimization" title="Permalink"></a></h3><p>The final step is to set the objective and run the optimization. This step is written out in the mathematic formulation and is just written out. The code to run the optimization is straight forward as well. <code>set_to_node_objectives</code> is a newer function that is required for solving the optimization problem.</p><p>The resulting output is the optimal values for <span>$x, u$</span>. For plotting and running this optimization over a long time period, we return the arrays of state variables and input variables. Recall, the code from step 2 to this step is wrapped in a function.</p><pre><code class="language-julia hljs">function add_objective!(graph_master)
    # Set objective
    @objective(
        graph_master, 
        Min, 
        sum(node[:u]&#39; * R * node[:u] for node in all_nodes(graph_master)) +
        sum(node[:x]&#39; * Q * node[:x] for node in all_nodes(graph_master)),
    )
end
    
function MHMPC(x0)
    graph_master = OptiGraph() # This will contain all subgraphs
    set_optimizer(graph_master, Ipopt.Optimizer)

    subgraphs_all, nodes_all = add_horizon_subgraphs()
    add_variables!(subgraphs_all, t_i, x0)
    add_constraints!(graph_master, subgraphs_all, nodes_all)
    add_objective!(graph_master)

    # Run optimization
    set_to_node_objectives(graph_master)
    set_optimizer_attribute(graph_master, &quot;print_level&quot;, 0)
    optimize!(graph_master)

    vals_x = []
    vals_y = []
    vals_u = []

    for node in all_nodes(graph_master)
        push!(vals_x, value(graph_master, node[:x][1]))
        push!(vals_y, value(graph_master, node[:x][2]))
        push!(vals_u, value(graph_master, node[:u][1]))
    end

    return vals_x, vals_y, vals_u
end</code></pre><h3 id="6.-Run-the-program"><a class="docs-heading-anchor" href="#6.-Run-the-program">6. Run the program</a><a id="6.-Run-the-program-1"></a><a class="docs-heading-anchor-permalink" href="#6.-Run-the-program" title="Permalink"></a></h3><p>In context of the spring damper system, we want to apply an optimal force <span>$u$</span> to dampen the system to position <span>$0$</span>, and <span>$0$</span> velocity. This optimization problem will give values for <span>$u$</span> at each time discretization node. For our purposes, we choose to run this program an arbitrary <span>$400$</span> times, once every <span>$0.05$</span> seconds. Thus every time step (<span>$0.05$</span> seconds), the future state variables will be parameters to the next optimization problem.</p><pre><code class="language-julia hljs">function run_sim(T::Int = 401)
    x_arr = Vector{Vector{Float64}}() # array of state variables at each timepoint
    u_arr = Vector{Float64}() # array of input variables at each time point

    x = [18.0, -14.0]
    push!(x_arr, x)

    for _ in 2:T
        vals_x1, vals_x2, vals_u = MHMPC(x)
        x = [vals_x1[2], vals_x2[2]]
        push!(x_arr, x)
        push!(u_arr, vals_u[1])
    end

    return x_arr, u_arr
end


x_sim, u_sim = run_sim()</code></pre><p>Now, plotting the values of <span>$x$</span> from our program:</p><p><img src="../../assets/plasmo_mhmpc.png" alt="room_figure"/> </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../supply_chain/">« Supply Chain Optimization</a><a class="docs-footer-nextpage" href="../quadcopter/">Optimal Control of a Quadcopter »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 12 November 2025 00:57">Wednesday 12 November 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
