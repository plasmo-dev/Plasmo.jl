<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Partitioning and Graph Operations · Plasmo.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Plasmo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Plasmo.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../modeling/">Modeling</a></li><li class="is-active"><a class="tocitem" href>Partitioning and Graph Operations</a><ul class="internal"><li><a class="tocitem" href="#Example-Problem:-Dynamic-Optimization"><span>Example Problem: Dynamic Optimization</span></a></li><li><a class="tocitem" href="#Partitioning-OptiGraphs"><span>Partitioning OptiGraphs</span></a></li><li><a class="tocitem" href="#Aggregating-OptiGraphs"><span>Aggregating OptiGraphs</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../../tutorials/tutorials/">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Partitioning and Graph Operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Partitioning and Graph Operations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/zavalab/Plasmo.jl/blob/master/docs/src/documentation/partitioning.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Partitioning-and-Graph-Operations"><a class="docs-heading-anchor" href="#Partitioning-and-Graph-Operations">Partitioning and Graph Operations</a><a id="Partitioning-and-Graph-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioning-and-Graph-Operations" title="Permalink"></a></h1><p>The <a href="../modeling/#Modeling">Modeling</a> section describes how to construct optigraphs using a bottom-up approach.  Specifically, we showed how to to use <a href="../modeling/#Hierarchical-Modeling">Hierarchical Modeling</a> with subgraphs to create multi-level optigraphs. This part of the documentation deals with creating optigraphs using a top-down approach. Specifically, we show how to construct subgraphs using graph partitions and show how <code>Plasmo.jl</code> interfaces with standard graph partitioning tools such as <a href="https://github.com/JuliaSparse/Metis.jl">Metis</a> and <a href="https://github.com/kahypar/KaHyPar.jl">KaHyPar</a>.</p><h2 id="Example-Problem:-Dynamic-Optimization"><a class="docs-heading-anchor" href="#Example-Problem:-Dynamic-Optimization">Example Problem: Dynamic Optimization</a><a id="Example-Problem:-Dynamic-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Problem:-Dynamic-Optimization" title="Permalink"></a></h2><p>To help demonstrate graph partitioning capabilities in <code>Plasmo.jl</code>, we instantiate a simple optimal control problem described by the following equations. In this problem, <span>$x$</span> is a vector of states and <span>$u$</span> is a vector of control actions which are both indexed over the set of time indices <span>$t \in \{1,...,T\}$</span>. The objective function minimizes the state trajectory with minimal control effort (energy), the second equation describes the state dynamics, and the third equation defines the initial condition. The last two equations define limits on the state and control actions.</p><div>\[\begin{aligned}
    \min_{\{ x,u \}} &amp; \sum_{t = 1}^T x_t^2 + u_t^2  &amp; \\
    \textrm{s.t.} \quad &amp; x_{t+1} = x_t + u_t + d_t, \quad t \in \{1,...,T-1\}  &amp; \\
    &amp; x_{1} = 0  &amp;\\
    &amp; x_t \ge 0, \quad t \in \{1,...,T\}\\
    &amp; u_t \ge -1000, \quad t \in \{1,...,T-1\}
\end{aligned}\]</div><p>This snippet shows how to construct the optimal control problem in <code>Plasmo.jl</code> as described in <a href="../modeling/#Modeling">Modeling</a>. We create an optigraph, add optinodes which represent states and controls at each time period, we set objective functions for each optinode, and we use linking constraints to describe the dynamics.</p><pre><code class="language-julia">using Plasmo

T = 100          #number of time points
d = sin.(1:T)    #disturbance vector

graph = OptiGraph()
@optinode(graph,state[1:T])
@optinode(graph,control[1:T-1])

for node in state
    @variable(node,x)
    @constraint(node, x &gt;= 0)
    @objective(node,Min,x^2)
end
for node in control
    @variable(node,u)
    @constraint(node, u &gt;= -1000)
    @objective(node,Min,u^2)
end

@linkconstraint(graph,[i = 1:T-1],state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])
n1 = state[1]
@constraint(n1,n1[:x] == 0)</code></pre><p>When we print the newly created optigraph for our optimal control problem, we see it contains about 200 optinodes (one for each state and control) and contains almost 100 linking constraints (which couple the time periods).</p><pre><code class="language-julia-repl">julia&gt; println(graph)
OptiGraph:
local nodes: 199, total nodes: 199
local link constraints: 99, total link constraints 99
local subgraphs: 0, total subgraphs 0</code></pre><p>We can also plot the resulting optigraph (see <a href="../plotting/#Plotting">Plotting</a>) which produces a simple chain, but otherwise there is no real structure in the problem as we have modeled it.</p><pre><code class="language-julia-repl">julia&gt; using Plots

julia&gt; plt_chain = plt_graph4 = plot(graph,layout_options = Dict(:tol =&gt; 0.1,:iterations =&gt; 500), linealpha = 0.2,markersize = 6)
Plot{Plots.GRBackend() n=298}

julia&gt; Plots.savefig(plt_chain,&quot;chain_layout.svg&quot;);

julia&gt; plt_chain_matrix = spy(graph);

julia&gt; Plots.savefig(plt_chain_matrix,&quot;chain_layout_matrix.svg&quot;);</code></pre><img src="../chain_layout.svg" alt="chain" width="400"/><img src="../chain_layout_matrix.svg" alt="chain_matrix" width="400"/><h2 id="Partitioning-OptiGraphs"><a class="docs-heading-anchor" href="#Partitioning-OptiGraphs">Partitioning OptiGraphs</a><a id="Partitioning-OptiGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioning-OptiGraphs" title="Permalink"></a></h2><p>At its core, the <a href="../modeling/#Plasmo.OptiGraph"><code>OptiGraph</code></a> is a <a href="https://en.wikipedia.org/wiki/Hypergraph">hypergraph</a> and can thus naturally exploit hypergraph partitioning tools.   For our example here we demonstrate how to use hypergraph partitioning (using <a href="https://github.com/kahypar/KaHyPar.jl">KaHyPar</a>), but <code>Plasmo.jl</code> also facilitates using standard graph partitioning algorithms  (a hypergraph can be projected to various standard graph representations) or partitioning by manually defining partition vectors. The below snippet uses the <a href="#Plasmo.gethypergraph"><code>gethypergraph</code></a> function which returns a <a href="#Plasmo.HyperGraph"><code>HyperGraph</code></a> object and a <code>hyper_map</code> (a Julia dictionary) which maps hypernodes and hyperedges back to the original optigraph.</p><pre><code class="language-julia-repl">julia&gt; hypergraph,hyper_map = gethypergraph(graph);

julia&gt; println(hypergraph)
Hypergraph: (199 , 99)</code></pre><p>With our <code>hypergraph</code> we can now use <code>KaHyPar</code> to perform hypergraph partitioning in the next snippet which returns a <code>partition_vector</code> . Each index in the <code>partition_vector</code> corresponds to a hypernode index in <code>hypergraph</code>, and each value denotes which partition the hypernode belongs to.  So in our example, <code>partition_vector</code> contains 199 elements which can take on integer values between 0 and 7 (for 8 total partitions). Once we have a <code>partition_vector</code>, we can create a <a href="#Plasmo.Partition"><code>Partition</code></a> object which describes sets (partitions) of optinodes and optiedges, as well as the shared optinodes and optiedges that cross partitions. We can lastly use the produced <code>partition</code> (a <code>Partition</code> object) to formulate subgraphs in our original optigraph (<code>graph</code>) using <a href="#Plasmo.make_subgraphs!"><code>make_subgraphs!</code></a>. After doing so, we see that our <code>graph</code> now contains 8 subgraphs with 7 linking constraints that correspond to the optiedges that cross partitions (i.e. connect subgraphs).</p><pre><code class="language-julia">julia&gt; using KaHyPar

julia&gt; partition_vector = KaHyPar.partition(hypergraph,8,configuration = :connectivity,imbalance = 0.01);

julia&gt; partition = Partition(graph,partition_vector,hyper_map);

julia&gt; make_subgraphs!(graph,partition);</code></pre><pre><code class="language-julia-repl">julia&gt; println(length(partition_vector))
199

julia&gt; println(partition)
    OptiGraph Partition w/ 8 subpartitions

julia&gt; println(length(getsubgraphs(graph)))
8

julia&gt; num_linkconstraints(graph)
7</code></pre><p>If we plot the partitioned optigraph, it reveals eight distinct partitions and the coupling between them. The plots show that the partitions are well-balanced and the matrix visualization shows the problem is reordered into a banded structure that is typical of dynamic optimization problems.</p><pre><code class="language-julia-repl">julia&gt; plt_chain_partition = plot(graph,layout_options = Dict(:tol =&gt; 0.01, :iterations =&gt; 500),linealpha = 0.2,markersize = 6,subgraph_colors = true);

julia&gt; Plots.savefig(plt_chain_partition,&quot;chain_layout_partition.svg&quot;);

julia&gt; plt_chain_matrix_partition = spy(graph,subgraph_colors = true);

julia&gt; Plots.savefig(plt_chain_matrix_partition,&quot;chain_layout_matrix_partition.svg&quot;);</code></pre><img src="../chain_layout_partition.svg" alt="chain_partition" width="400"/><img src="../chain_layout_matrix_partition.svg" alt="chain_matrix_partition" width="400"/><h2 id="Aggregating-OptiGraphs"><a class="docs-heading-anchor" href="#Aggregating-OptiGraphs">Aggregating OptiGraphs</a><a id="Aggregating-OptiGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregating-OptiGraphs" title="Permalink"></a></h2><p>Subgraphs can be converted into stand-alone optinodes using the using the <a href="#Plasmo.aggregate"><code>aggregate</code></a> function. This is important from a solver stand-point because optinodes represent solvable subproblems which can be communicated to decomposition algorithms. This aggregation step also takes place when using standard optimization solvers with <code>Plasmo.jl</code>, such as <code>Ipopt</code> wherein the optigraph is aggregated into a single optinode and solved using the underlying <code>JuMP</code> interface. In the snippet below, we aggregate our optigraph that contains 8 subgraphs.  We include the argument <code>0</code> which specifies how many subgraph levels to retain.  In this case, <code>0</code> means we aggregate subgraphs at the highest level so <code>graph</code> contains only new aggregated optinodes. For hierarchical graphs with many levels, we can define how many subgraph levels we wish to retain. The function returns a new aggregated graph (<code>aggregate_graph</code>), as well as <code>reference_map</code> which maps variables in <code>aggregate_graph</code> to the original optigraph <code>graph</code>.</p><pre><code class="language-julia-repl">julia&gt; aggregate_graph,reference_map = aggregate(graph,0);
Creating Combined OptiGraph with a maximum subgraph depth of 0

julia&gt; println(aggregate_graph)
OptiGraph:
local nodes: 8, total nodes: 8
local link constraints: 7, total link constraints 7
local subgraphs: 0, total subgraphs 0</code></pre><p>We can lastly plot the aggregated graph structure which simply shows 8 optinodes with 7 linking constraints.</p><pre><code class="language-julia-repl">julia&gt; plt_chain_aggregate = plot(aggregate_graph,layout_options = Dict(:tol =&gt; 0.01,:iterations =&gt; 10),node_labels = true,markersize = 30,labelsize = 20,node_colors = true);

julia&gt; Plots.savefig(plt_chain_aggregate,&quot;chain_layout_aggregate.svg&quot;);

julia&gt; plt_chain_matrix_aggregate = spy(aggregate_graph,node_labels = true,node_colors = true);

julia&gt; Plots.savefig(plt_chain_matrix_aggregate,&quot;chain_layout_matrix_aggregate.svg&quot;);</code></pre><img src="../chain_layout_aggregate.svg" alt="chain_aggregate" width="400"/><img src="../chain_layout_matrix_aggregate.svg" alt="chain_matrix_aggregate" width="400"/><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Plasmo.Partition" href="#Plasmo.Partition"><code>Plasmo.Partition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Partition(hypergraph::HyperGraph,node_membership_vector::Vector{Int64},ref_map::Dict)</code></pre><p>Create a partition of optinodes using <code>hypergraph</code>, <code>node_membership_vector</code>, and &#39;ref<em>map&#39;.  The &#39;ref</em>map&#39; is a dictionary that maps hypernode indices (integers) and hyperedge indices (tuples) back to optinodes and optiedges.</p><pre><code class="language-none">Partition(optigraph::OptiGraph,node_membership_vector::Vector{Int64},ref_map::Dict)</code></pre><p>Create a partition using <code>optigraph</code>, <code>node_membership_vector</code>, and &#39;ref<em>map&#39;. The `ref</em>map` is a mapping of node_indices to the original optinodes.</p><pre><code class="language-none">Partition(optigraph::OptiGraph,optinode_vectors::Vector{Vector{OptiNode}})</code></pre><p>Manually create a partition using <code>optigraph</code> and a vector of vectors containing sets of optinodes that represent each partition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/1c60da2b1830de91f2c81a6d89170bb610d08f00/src/partition.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.make_subgraphs!" href="#Plasmo.make_subgraphs!"><code>Plasmo.make_subgraphs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_subgraphs!(optigraph::OptiGraph,partition::Partition)</code></pre><p>Create subgraphs in <code>optigraph</code> using a produced &#39;partition&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/1c60da2b1830de91f2c81a6d89170bb610d08f00/src/partition.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.aggregate" href="#Plasmo.aggregate"><code>Plasmo.aggregate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aggregate(graph::OptiGraph)</code></pre><p>Aggregate the optigraph <code>graph</code> into a new optinode.  Return an optinode and a dictionary which maps optinode variable and constraint references to the original optigraph.</p><pre><code class="language-none">aggregate(graph::OptiGraph,max_depth::Int64)</code></pre><p>Aggregate the optigraph &#39;graph&#39; into a new aggregated optigraph. Return a newly aggregated optigraph and a dictionary which maps new variables and constraints to the original optigraph. <code>max_depth</code> determines how many levels of subgraphs remain in the new aggregated optigraph. For example, a <code>max_depth</code> of <code>0</code> signifies there should be no subgraphs in the aggregated optigraph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/1c60da2b1830de91f2c81a6d89170bb610d08f00/src/combine.jl#L100-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.expand" href="#Plasmo.expand"><code>Plasmo.expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand(graph::OptiGraph,subgraph::OptiGraph,distance::Int64)</code></pre><p>Return a new expanded subgraph given the optigraph <code>graph</code> and an existing subgraph <code>subgraph</code>. The returned subgraph contains the expanded neighborhood within <code>distance</code> of the given <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/1c60da2b1830de91f2c81a6d89170bb610d08f00/src/graph_functions.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.neighborhood" href="#Plasmo.neighborhood"><code>Plasmo.neighborhood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">neighborhood(graph::OptiGraph,nodes::Vector{OptiNode},distance::Int64)::Vector{OptiNode}</code></pre><p>Return the optinodes within <code>distance</code> of the given <code>nodes</code> in the optigraph <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/1c60da2b1830de91f2c81a6d89170bb610d08f00/src/graph_functions.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.HyperGraph" href="#Plasmo.HyperGraph"><code>Plasmo.HyperGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Hypergraph</code></pre><p>A simple hypergraph type.  Contains attributes for vertices and hyperedges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/1c60da2b1830de91f2c81a6d89170bb610d08f00/src/hypergraphs/hypergraph.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plasmo.gethypergraph" href="#Plasmo.gethypergraph"><code>Plasmo.gethypergraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gethypergraph(graph::OptiGraph)</code></pre><p>Retrieve a hypergraph representation of the optigraph <code>graph</code>. Returns a <a href="#Plasmo.HyperGraph"><code>HyperGraph</code></a> object, as well as a dictionary that maps hypernodes and hyperedges to the original optinodes and optiedges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zavalab/Plasmo.jl/blob/1c60da2b1830de91f2c81a6d89170bb610d08f00/src/graph_interface.jl#L5-L10">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modeling/">« Modeling</a><a class="docs-footer-nextpage" href="../solvers/">Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 12 September 2020 03:09">Saturday 12 September 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
