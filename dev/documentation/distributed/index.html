<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Plasmo.jl</title><meta name="title" content="Introduction · Plasmo.jl"/><meta property="og:title" content="Introduction · Plasmo.jl"/><meta property="twitter:title" content="Introduction · Plasmo.jl"/><meta name="description" content="Documentation for Plasmo.jl."/><meta property="og:description" content="Documentation for Plasmo.jl."/><meta property="twitter:description" content="Documentation for Plasmo.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Plasmo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Plasmo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../modeling/">Modeling with OptiGraphs</a></li><li><a class="tocitem" href="../graph_processing/">Graph Processing and Analysis</a></li><li><a class="tocitem" href="../api_docs/">API Documentation</a></li><li><span class="tocitem">Distributed Memory</span><ul><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#RemoteOptiGraph-Overview"><span><code>RemoteOptiGraph</code> Overview</span></a></li><li><a class="tocitem" href="#Introduction-to-Distributed-Programming"><span>Introduction to Distributed Programming</span></a></li><li><a class="tocitem" href="#Data-Structure"><span>Data Structure</span></a></li><li><a class="tocitem" href="#Decomposition-Schemes-for-Working-with-RemoteOptiGraphs"><span>Decomposition Schemes for Working with <code>RemoteOptiGraph</code>s</span></a></li></ul></li><li><a class="tocitem" href="../distributed_quickstart/">Quickstart</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/supply_chain/">Supply Chain Optimization</a></li><li><a class="tocitem" href="../../tutorials/MHMPC/">Multi-Horizon Model Predictive Control</a></li><li><a class="tocitem" href="../../tutorials/quadcopter/">Optimal Control of a Quadcopter</a></li><li><a class="tocitem" href="../../tutorials/HVAC/">Hierarchical HVAC Optimization</a></li><li><a class="tocitem" href="../../tutorials/gas_pipeline/">Optimal Control of a Natural Gas Network</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Distributed Memory</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/plasmo-dev/Plasmo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/plasmo-dev/Plasmo.jl/blob/main/docs/src/documentation/distributed.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Plasmo.jl-for-Distributed-Memory"><a class="docs-heading-anchor" href="#Plasmo.jl-for-Distributed-Memory">Plasmo.jl for Distributed Memory</a><a id="Plasmo.jl-for-Distributed-Memory-1"></a><a class="docs-heading-anchor-permalink" href="#Plasmo.jl-for-Distributed-Memory" title="Permalink"></a></h1><h2 id="RemoteOptiGraph-Overview"><a class="docs-heading-anchor" href="#RemoteOptiGraph-Overview"><code>RemoteOptiGraph</code> Overview</a><a id="RemoteOptiGraph-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#RemoteOptiGraph-Overview" title="Permalink"></a></h2><p>In large-scale problems, there can be instances where memory limits optimization or decomposition approaches. In such cases, it can be necessary to distribute the optimization problem to multiple processors. Plasmo.jl has support for placing subgraphs of an optimization problem on separate workers by using the <code>RemoteOptiGraph</code> object. At the moment, this is primarily used when applying a decomposition approach where you may want separate subproblems that can be solved on separate workers while still capturing connections (e.g., constraints as edges) between the subproblems. </p><p>The <code>RemoteOptiGraph</code> object can be thought of as a wrapper for an <code>OptiGraph</code> that is stored on a remote worker. The <code>RemoteOptiGraph</code> wrapper &quot;lives&quot; on the primary worker running the Julia REPL while the <code>OptiGraph</code> itself is stored on a remote process. The <code>RemoteOptiGraph</code> can also have nested subgraphs (just like an <code>OptiGraph</code> can contain nested <code>OptiGraph</code>s) with each subgraph stored on a worker and can contain <code>InterWorkerEdge</code>s that connect the nested <code>RemoteOptiGraph</code>s together (or connect nested <code>RemoteOptiGraph</code>s with nodes on the primary <code>RemoteOptiGraph</code> with its subgraphs). </p><p>From a user point of view, the <code>RemoteOptiGraph</code> functions similarly to an <code>OptiGraph</code>. The macros <code>@variable</code>, <code>@constraint</code>, <code>@optinode</code>, and <code>@objective</code> work in the same way for a <code>RemoteOptiGraph</code> as an <code>OptiGraph</code>. These macros, as well as many other JuMP and Plasmo functions have been extended to work with the <code>RemoteOptiGraph</code> object. &quot;Lightweight&quot; remote object references are returned by these functions that point to their corresponding objects stored on the <code>OptiGraph</code> on the remote worker.</p><h2 id="Introduction-to-Distributed-Programming"><a class="docs-heading-anchor" href="#Introduction-to-Distributed-Programming">Introduction to Distributed Programming</a><a id="Introduction-to-Distributed-Programming-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Distributed-Programming" title="Permalink"></a></h2><p>Plasmo.jl&#39;s distributed functionality is enabled by Distributed.jl and DistributedArrays.jl. While Plasmo.jl&#39;s distributed functionality is designed so that the user largely does not have to interact with the commands to access distributed information, the information in this subsection will be helpful in getting started, building performant code, and debugging models. While this subsection provides some basic information needed for effectively building <code>RemoteOptiGraph</code>s, further details can be found at <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/">Distributed.jl</a> and <a href="https://juliaparallel.org/DistributedArrays.jl/stable/">DistributedArrays.jl</a>&#39;s source code. </p><p>Julia&#39;s default is to run code on a main processor or worker. To run distributed code, the user must define additional processors/workers. Distributed.jl refers to the processors in the cluster as <code>procs</code> or processors and the remote workers (outside of the main worker on which the REPL is running) as <code>workers</code>. Calling <code>nprocs()</code> will return the number of processors currently running/accessible while <code>nworkers()</code> will return the number of worker processors (typically <code>nprocs() - 1</code>). Each processor is referenced by an integer ID. The main processor (on which the Julia REPL is running) is always <code>1</code>. To get the set of processor or worker IDs, a user can call <code>procs</code> and <code>workers</code>. </p><p>To run on additional workers, a user must start additional workers in Julia and define code to run on the workers. Additional workers can be added by calling <code>addprocs(num_cpus)</code> where <code>num_cpus</code> is an integer value for the number of processors to add or start. Similarly, a user can run <code>rmprocs</code> to shutdown and remove one or more Julia processors. Once an additional worker is started, a user must also load required packages (e.g., Plasmo) on the worker they want to use. This can be done via the <code>@everywhere</code> macro, which will run the code inside the macro on every worker. For instance, the user can run the following: </p><pre><code class="language-julia hljs">using Distributed, Plasmo, JuMP

# add three processors
println(nprocs()) # returns 1
addprocs(3)
println(nprocs()) # returns 4

# Plasmo and JuMP are not defined on the remote workers yet until @everywhere is called
@everywhere begin
    using Plasmo
    using JuMP
end</code></pre><p>To run a task on the distributed worker, a user must use functions from Distributed.jl such as <code>remotecall</code> or <code>@spawnat</code>. As an example, <code>remotecall</code> will run a function on a remote worker, such as in the following case: </p><pre><code class="language-julia hljs">workers = workers()
A = rand(5000)

f = remotecall(maximum, workers[1], A)</code></pre><p>Here, <code>remotecall</code> runs <code>maximum(A)</code> on the first worker indexed in the worker pool. Alternatively, a user can use the <code>@spawnat</code> macro to run code such as in the following case: </p><pre><code class="language-julia hljs">f = @spawnat 2 begin
    A = rand(5000)
    maximum(A)
end</code></pre><p>In this latter example, the matrix <code>A</code> is never defined on the main worker and is not accessible in the main Julia REPL because the code was run only on the remote worker. In both cases above, <code>f</code> is a <code>Future</code> object, meaning it is a reference to the task performed on the worker. Note that a user might expect this to return a Float value (the maximum value in the random vector), but the <code>Future</code> object is just a reference to what has been done on the remote worker. To get the value of the <code>Future</code> object, a user must &quot;fetch&quot; the value from the worker by calling <code>fetch(f)</code>, which will return the expected Float value. </p><h3 id="Cautions-with-Distributed-Programming"><a class="docs-heading-anchor" href="#Cautions-with-Distributed-Programming">Cautions with Distributed Programming</a><a id="Cautions-with-Distributed-Programming-1"></a><a class="docs-heading-anchor-permalink" href="#Cautions-with-Distributed-Programming" title="Permalink"></a></h3><p>While distributed programming can be useful and accelerate task performance on some problems, there are tradeoffs. Variables, functions, or other allocated memory defined on the main processor are not shared directly with the remote workers. Thus at least two places a user may lose performance in their code is 1) making many calls to the remote worker (e.g., many <code>fetch</code> or <code>@spawnat</code> calls) and 2) passing large datastructures between the main and remote processors. A user must therefore be careful about both of these tasks. </p><h4 id="Limiting-calls-to-the-remote"><a class="docs-heading-anchor" href="#Limiting-calls-to-the-remote">Limiting calls to the remote</a><a id="Limiting-calls-to-the-remote-1"></a><a class="docs-heading-anchor-permalink" href="#Limiting-calls-to-the-remote" title="Permalink"></a></h4><p>As an example of the first challenge, the second function below will be more efficient than the first because there is only one <code>remotecall</code> to the worker and only one <code>fetch</code> call, or said another way, the second function outperforms the first because it transfers all of the matrix <code>A</code> in one call, rather than having repeated calls to transfer <code>A</code> a row at a time. </p><pre><code class="language-julia hljs">A = rand(100, 100)
function do_remote_task_v1(A::Matrix, worker_id::Int)
    max_values = zeros(100)
    for i in 1:100
        row = A[i, :]
        f = @spawnat worker_id begin
            maximum(row)
        end
        max_values[i] = fetch(f)
    end
    return max_values
end

function do_remote_task_v2(A::Matrix, worker_id::Int)
    f = @spawnat worker_id begin
        max_values = zeros(100)
        for i in 1:100
            row = A[i, :]
            max_values[i] = maximum(row)
        end
        max_values
    end
    return fetch(f)
end</code></pre><p>In terms of Plasmo.jl performance, it can be helpful to define constructor functions for graphs that are being built on remote workers. Building large graphs from many different <code>@variable</code> or <code>@constraint</code> calls on the main processor will work but can be slower than running these directly on the remote worker. This is discussed in more detail in the Quickstart on distributed Plasmo.jl. </p><h4 id="Limiting-memory-sent-to-the-remote"><a class="docs-heading-anchor" href="#Limiting-memory-sent-to-the-remote">Limiting memory sent to the remote</a><a id="Limiting-memory-sent-to-the-remote-1"></a><a class="docs-heading-anchor-permalink" href="#Limiting-memory-sent-to-the-remote" title="Permalink"></a></h4><p>Memory form the main worker is shared to the remote worker inside of <code>remotecall</code> or <code>@spawnat</code>, and the user must be careful in what information is shared in these remote calls. For instance, in the following case, the entire <code>A</code> matrix is being shared to the remote worker since it is explicitly referenced inside the <code>@spawnat</code> call even though only one entry of the <code>A</code> matrix is necessary. </p><pre><code class="language-julia hljs">A = rand(100, 100)
f = @spawnat workers[1] begin
    A[1, 1] ** 2
end
fetch(f)</code></pre><p>As a more efficient option in terms of what memory is implicitly communicated, the user can create a reference/variable for this single entry outside of the fetch call, such as the following: </p><pre><code class="language-julia hljs">A = rand(100, 100)
first_entry = A[1,1]
f = @spawnat workers[1] begin
    first_entry ** 2
end
fetch(f)</code></pre><p>In the case of Plasmo.jl (or JuMP.jl for that matter), sharing pieces of a traditional optimization problem across workers can include the entire optimization problem. For instance, because each <code>Plasmo.NodeVariableRef</code> includes a reference to a node and each node includes a reference to a graph, passing a <code>Plasmo.NodeVariableRef</code> shares the entire OptiGraph between workers. This was a major motivation for the <code>RemoteOptiGraph</code> abstraction, which has been implemented such that only the required data (e.g., the <code>MOI.VariableIndex</code>) is passed between workers and does not include a reference to the full graph. </p><h2 id="Data-Structure"><a class="docs-heading-anchor" href="#Data-Structure">Data Structure</a><a id="Data-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structure" title="Permalink"></a></h2><p>Plasmo.jl&#39;s distributed implementation is built on the <code>RemoteOptiGraph</code> data object. This object includes a <code>worker</code> field, which is the remote worker on which the actual <code>OptiGraph</code> is stored. The <code>graph</code> field is a length 1 <code>DArray</code> (a distributed array). The <code>DArray</code> is a light &quot;wrapper&quot; of sorts that stores the actual <code>OptiGraph</code> on the remote worker. <code>RemoteOptiGraph</code>s can also be nested in other <code>RemoteOptiGraphs</code> just as <code>OptiGraph</code>s can be, so there are also fields called <code>parent_graph</code> and <code>subgraphs</code>. Finally, there are fields <code>optiedges</code>, <code>element_data</code>, <code>obj_data</code>, <code>label</code>, and <code>ext</code>. </p><p>Several reference types and objects have been defined for working with the distributed implementation. The <code>RemoteOptiGraph</code> object &quot;lives on the main worker and is essentially a wrapper and pointer to an <code>OptiGraph</code> on the remote worker. Nodes, edges, and variables from the <code>OptiGraph</code> on the remote worker can be referenced on the main worker via the structs <code>RemoteNodeRef</code>, <code>RemoteEdgeRef</code>, and <code>RemoteVariableRef</code>. Each of these objects belongs to the <code>RemoteOptiGraph</code> but includes information that points to the objects on the remote worker. In this way, the functions for working with Plasmo.jl&#39;s <code>OptiGraph</code> object have been extended for working with these remote reference objects. For instance, calling <code>@optinode</code> and passing a <code>RemoteOptiGraph</code> object will add the node to the <code>OptiGraph</code> on the remote worker and return a <code>RemoteNodeRef</code> to the main worker that represents the actual node added on the remote worker. Similarly, passing a <code>RemoteNodeRef</code> to the <code>@variable</code> constructs variables on the remote worker&#39;s <code>OptiGraph</code> but returns <code>RemoteVariableRef</code> objects on the main worker. Examples of many of these functions are included in the <a href="../distributed_quickstart/#Distributed-OptiGraph-QuickStart">Distributed OptiGraph QuickStart</a>.</p><p>The other important data structure is the <code>InterWorkerEdge</code>. This object captures constraints between multiple <code>RemoteOptiGraph</code>s. Since <code>RemoteOptiGraph</code>s can capture nested structures, constraints between these structures are stored on the <code>InterWorkerEdge</code>. These constraints are stored directly on the <code>RemoteOptiGraph</code> object. In this way, the <code>RmeoteOptiEdge</code> structure is different than the <code>RemoteEdgeRef</code>, since the latter represents an edges contained in the <code>OptiGraph</code> object stored on the remote worker.</p><p>Finally, we note on these <code>RemoteOptiGraph</code> objects are likely most useful for decomposition approaches or situations where there are memory limiations. Unlike the <code>OptiGraph</code> abstraction, calling <code>JuMP.optimize!</code> on a <code>RemoteOptiGraph</code> only optimizes the <code>OptiGraph</code> that is stored remotely on the <code>RemoteOptiGraph</code> and does NOT consider subgraphs. When optimizing an <code>OptiGraph</code>, calling <code>JuMP.optimize!</code> will include all subgraphs in the optimization problem, but this is not the case of the remote. </p><h2 id="Decomposition-Schemes-for-Working-with-RemoteOptiGraphs"><a class="docs-heading-anchor" href="#Decomposition-Schemes-for-Working-with-RemoteOptiGraphs">Decomposition Schemes for Working with <code>RemoteOptiGraph</code>s</a><a id="Decomposition-Schemes-for-Working-with-RemoteOptiGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#Decomposition-Schemes-for-Working-with-RemoteOptiGraphs" title="Permalink"></a></h2><p>The package PlasmoBenders.jl has been designed to work with both Plasmo.jl&#39;s <code>OptiGraph</code>s and <code>RemoteOptiGraph</code>s. This package implements Benders decomposition and is available <a href="https://github.com/plasmo-dev/PlasmoAlgorithms.jl/tree/main/lib/PlasmoBenders">here</a>. Using the <code>RemoteOptiGraph</code>s with PlasmoBenders.jl requires PlasmoBenders v0.2.0+.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api_docs/">« API Documentation</a><a class="docs-footer-nextpage" href="../distributed_quickstart/">Quickstart »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 12 November 2025 00:57">Wednesday 12 November 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
