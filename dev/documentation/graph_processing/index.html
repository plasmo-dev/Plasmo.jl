<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graph Processing and Analysis · Plasmo.jl</title><meta name="title" content="Graph Processing and Analysis · Plasmo.jl"/><meta property="og:title" content="Graph Processing and Analysis · Plasmo.jl"/><meta property="twitter:title" content="Graph Processing and Analysis · Plasmo.jl"/><meta name="description" content="Documentation for Plasmo.jl."/><meta property="og:description" content="Documentation for Plasmo.jl."/><meta property="twitter:description" content="Documentation for Plasmo.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Plasmo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Plasmo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../modeling/">Modeling with OptiGraphs</a></li><li class="is-active"><a class="tocitem" href>Graph Processing and Analysis</a><ul class="internal"><li><a class="tocitem" href="#Illustrative-Example:-Dynamic-Optimization"><span>Illustrative Example: Dynamic Optimization</span></a></li><li><a class="tocitem" href="#OptiGraph-Projections"><span>OptiGraph Projections</span></a></li><li><a class="tocitem" href="#Querying-Topology"><span>Querying Topology</span></a></li><li><a class="tocitem" href="#Assembling-New-OptiGraphs"><span>Assembling New OptiGraphs</span></a></li><li><a class="tocitem" href="#Partitioning-OptiGraphs"><span>Partitioning OptiGraphs</span></a></li><li><a class="tocitem" href="#Aggregating-OptiGraphs-(Experimental)"><span>Aggregating OptiGraphs (Experimental)</span></a></li></ul></li><li><a class="tocitem" href="../api_docs/">API Documentation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/supply_chain/">Supply Chain Optimization</a></li><li><a class="tocitem" href="../../tutorials/quadcopter/">Optimal Control of a Quadcopter</a></li><li><a class="tocitem" href="../../tutorials/gas_pipeline/">Optimal Control of a Natural Gas Network</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Graph Processing and Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Graph Processing and Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/plasmo-dev/Plasmo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/plasmo-dev/Plasmo.jl/blob/main/docs/src/documentation/graph_processing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Graph-Processing-and-Analysis"><a class="docs-heading-anchor" href="#Graph-Processing-and-Analysis">Graph Processing and Analysis</a><a id="Graph-Processing-and-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Processing-and-Analysis" title="Permalink"></a></h1><p>In <a href="../modeling/#Modeling-with-OptiGraphs">Modeling with OptiGraphs</a> we describe how to construct optigraphs using a bottom-up approach that manages problem structure using nodes, edges, and subgraphs. Plasmo.jl also supports managing optigraphs in a more top-down manner using graph analysis functions and interfaces to standard graph partitioning tools such as <a href="https://github.com/JuliaSparse/Metis.jl">Metis</a> and <a href="https://github.com/kahypar/KaHyPar.jl">KaHyPar</a>. </p><h2 id="Illustrative-Example:-Dynamic-Optimization"><a class="docs-heading-anchor" href="#Illustrative-Example:-Dynamic-Optimization">Illustrative Example: Dynamic Optimization</a><a id="Illustrative-Example:-Dynamic-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Illustrative-Example:-Dynamic-Optimization" title="Permalink"></a></h2><p>To help demonstrate some graph processing capabilities in Plasmo.jl, we construct a simple optimal control problem described by the following equations. In this problem, <span>$x$</span> is a vector of states and <span>$u$</span> is a vector of control actions which are both indexed over the set of time indices <span>$t \in \{1,...,T\}$</span>. The objective function minimizes the state trajectory distance from zero with minimal control effort, the second equation describes the state dynamics, and the third equation defines the initial condition. The last two equations define limits on the state and control actions.</p><p class="math-container">\[\begin{aligned}
    \min_{\{ x,u \}} &amp; \sum_{t = 1}^T x_t^2 + u_t^2  &amp; \\
    \textrm{s.t.} \quad &amp; x_{t+1} = x_t + u_t + d_t, \quad t \in \{1,...,T-1\}  &amp; \\
    &amp; x_{1} = 0  &amp;\\
    &amp; x_t \ge 0, \quad t \in \{1,...,T\}\\
    &amp; u_t \ge -1000, \quad t \in \{1,...,T-1\}
\end{aligned}\]</p><p>This snippet shows how to construct the optimal control problem in Plasmo.jl. We create an optigraph, we add optinodes which contain states and controls at each time period, we setup objective functions for each node, and we use linking constraints to describe the dynamics (since each node represents a point in time). When we print the newly created optigraph for our optimal control problem, we see it contains about 200 optinodes (one for each state and control) and contains almost 100 linking constraints (which couple the time periods).</p><pre><code class="language-julia hljs">using Plasmo

T = 100          # number of time points
d = sin.(1:T)    # disturbance vector (a sin wave)

graph = OptiGraph(;name=:optimal_control)
@optinode(graph, state[1:T])
@optinode(graph, control[1:T-1])

for node in state
    @variable(node, x)
    @constraint(node, x &gt;= 0)
    @objective(node, Min, x^2)
end
for node in control
    @variable(node, u)
    @constraint(node, u &gt;= -1000)
    @objective(node, Min, u^2)
end

@linkconstraint(graph, [i = 1:T-1], state[i+1][:x] == state[i][:x] + control[i][:u] + d[i])
JuMP.fix(state[1][:x], 0)

graph

# output

An OptiGraph
 optimal_control #local elements  #total elements
--------------------------------------------------
          Nodes:       199              199
          Edges:        99               99
      Subgraphs:         0                0
      Variables:       199              199
    Constraints:       299              299
</code></pre><p>We can also plot the resulting optigraph (see [Plotting]) which produces a simple chain of optinodes.</p><pre><code class="language-julia hljs">using PlasmoPlots

plt_chain_layout = layout_plot(
    graph,
    layout_options=Dict(:tol=&gt;0.1,:iterations=&gt;500),
    linealpha = 0.2,
    markersize = 6
)

plt_chain_matrix = matrix_plot(graph)</code></pre><p><img src="../../assets/chain_layout.svg" alt="partition_layout_1"/> <img src="../../assets/chain_layout_matrix.svg" alt="partition_matrix_1"/></p><h2 id="OptiGraph-Projections"><a class="docs-heading-anchor" href="#OptiGraph-Projections">OptiGraph Projections</a><a id="OptiGraph-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#OptiGraph-Projections" title="Permalink"></a></h2><p>Plasmo.jl lets us query optigraph properties such as <a href="../api_docs/#Graphs.all_neighbors"><code>all_neighbors</code></a>, <a href="../api_docs/#Graphs.induced_subgraph"><code>induced_subgraph</code></a>, and <a href="../api_docs/#Plasmo.incident_edges"><code>incident_edges</code></a>. Before we can  query any of these properties, we need to create a hypergraph representation of the optigraph using a <a href="../api_docs/#Plasmo.GraphProjection"><code>Plasmo.GraphProjection</code></a>. Specifically, we want to  create a hypergraph projection using <a href="../api_docs/#Plasmo.hyper_projection"><code>hyper_projection</code></a> method.</p><pre><code class="language-julia-repl hljs">julia&gt; projection = hyper_projection(graph)
Graph Projection: Plasmo.HyperGraphProjectionType()
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Plasmo.jl contains a few different <a href="../api_docs/#Graph-Projections">Graph Projections</a>. The <a href="https://en.wikipedia.org/wiki/Hypergraph">hypergraph</a> is the most natural representation  of an optigraph and is used to perform most processing tasks such as querying neighbors and incident edges. Other projections can be useful for various graph analyses,  but no examples exist right now beyond graph partitioning. </p></div></div><p>The next most useful projection is probably the <a href="../api_docs/#Plasmo.clique_projection"><code>clique_projection</code></a>. This projection replaces each hyperedge with a set of standard edges to create a standard graph (where edges strictly  connect 2 nodes). This projection internally contains a <code>Graphs.SimpleGraph</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; clique_proj = clique_projection(graph)
Graph Projection: Plasmo.CliqueGraphProjectionType()

julia&gt; clique_proj.projected_graph
{199, 297} undirected simple Int64 graph
</code></pre><h2 id="Querying-Topology"><a class="docs-heading-anchor" href="#Querying-Topology">Querying Topology</a><a id="Querying-Topology-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-Topology" title="Permalink"></a></h2><p>Once we have a projection we can run all sorts of methods to query the topology, many of which are extended from <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a>. The below snippet demonstrates some of the primary methods. We first grab two nodes to start some examples. </p><pre><code class="language-julia-repl hljs">julia&gt; node1 = graph[1]
state[1]

julia&gt; node2 = graph[2]
state[2]</code></pre><p>Remember, <code>state[2]</code> is a function of state[1] and control[1] based on our modeled equations. We can query the neighbors of <code>node1 (state[1])</code> to confirm this. </p><pre><code class="language-julia-repl hljs">julia&gt; all_neighbors(projection, node1)
2-element Vector{OptiNode{OptiGraph}}:
 state[2]
 control[1]</code></pre><p>We can query the <a href="../api_docs/#Graphs.neighborhood"><code>neighborhood</code></a> around a node within a given distance (this function also returns the queried node).  For this example we use a distance of 1. We can also query a neighborhood given a set of nodes.</p><pre><code class="language-julia-repl hljs">julia&gt; neighborhood(projection, [node1], 1) 
3-element Vector{OptiNode{OptiGraph}}:
 state[1]
 state[2]
 control[1]

julia&gt; neighborhood(projection, [node1, node2], 1)
5-element Vector{OptiNode{OptiGraph}}:
 state[1]
 state[2]
 control[1]
 state[3]
 control[2]
</code></pre><p>We can look at edges incident to a single node or set of nodes.  Note that <code>state[1]</code> has one incident edge that connects it to <code>control[1]</code> and <code>state[2]</code>. We verify this by using <code>all_nodes</code> on the returned edge.</p><pre><code class="language-julia-repl hljs">julia&gt; node1_incident = incident_edges(projection, node1) 
1-element Vector{OptiEdge{OptiGraph}}:
 optimal_control.e1

julia&gt; edge1_nodes = all_nodes(node1_incident[1])
3-element Vector{OptiNode}:
 state[2]
 state[1]
 control[1]

julia&gt; incident_edges(projection, [node1,node2])
2-element Vector{OptiEdge{OptiGraph}}:
 optimal_control.e1
 optimal_control.e2
</code></pre><p>We lastly show how to query the edges induced by a set of nodes. These are all edges that connect the  given nodes.</p><pre><code class="language-julia-repl hljs">julia&gt; induced = induced_edges(projection, edge1_nodes)
1-element Vector{OptiEdge}:
 optimal_control.e1
</code></pre><h2 id="Assembling-New-OptiGraphs"><a class="docs-heading-anchor" href="#Assembling-New-OptiGraphs">Assembling New OptiGraphs</a><a id="Assembling-New-OptiGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-New-OptiGraphs" title="Permalink"></a></h2><p>A key capability that derives from graph topology queries is the ability to create  new optigraphs from subsets of nodes and edges. This is primarily done with the <code>assemble_optigraph</code>(@ref) method which some topology functions implicity call. Here we show how to create new optigraphs using some of these methods.</p><pre><code class="language-julia-repl hljs">julia&gt; queried_nodes = neighborhood(projection, [node1], 5)
11-element Vector{OptiNode{OptiGraph}}:
 state[1]
 state[2]
 control[1]
 state[3]
 control[2]
 state[4]
 control[3]
 state[5]
 control[4]
 state[6]
 control[5]

julia&gt; queried_edges = induced_edges(projection, queried_nodes)
5-element Vector{OptiEdge}:
 optimal_control.e1
 optimal_control.e2
 optimal_control.e3
 optimal_control.e4
 optimal_control.e5

julia&gt; new_graph = assemble_optigraph(queried_nodes, queried_edges; name=:new_graph)
An OptiGraph
       new_graph #local elements  #total elements
--------------------------------------------------
          Nodes:        11               11
          Edges:         5                5
      Subgraphs:         0                0
      Variables:        11               11
    Constraints:        17               17
</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>You must pass valid nodes and edges to <a href="../api_docs/#Plasmo.assemble_optigraph"><code>assemble_optigraph</code></a>. All of the edges must  be connected to the given nodes.</p></div></div><p>An easy alternative to using <a href="../api_docs/#Plasmo.assemble_optigraph"><code>assemble_optigraph</code></a> is to use <a href="../api_docs/#Graphs.induced_subgraph"><code>induced_subgraph</code></a> which takes a vector of nodes and does the above operations internally.</p><pre><code class="language-julia-repl hljs">julia&gt; new_graph = induced_subgraph(projection, queried_nodes; name=:induced_graph)
An OptiGraph
   induced_graph #local elements  #total elements
--------------------------------------------------
          Nodes:        11               11
          Edges:         5                5
      Subgraphs:         0                0
      Variables:        11               11
    Constraints:        17               17
</code></pre><p>We can lastly <a href="../api_docs/#Plasmo.expand"><code>expand</code></a> a set of nodes to create a new graph. We can provide either  a subgraph (an optigraph) or a set of nodes to expand with. This would look like the following:</p><pre><code class="language-julia-repl hljs">julia&gt; expanded_graph = expand(projection, new_graph, 1; name=:expanded_graph)
An OptiGraph
  expanded_graph #local elements  #total elements
--------------------------------------------------
          Nodes:        13               13
          Edges:         6                6
      Subgraphs:         0                0
      Variables:        13               13
    Constraints:        20               20

julia&gt; expanded_with_nodes = expand(projection, queried_nodes, 1; name=:expanded_nodes)
An OptiGraph
  expanded_nodes #local elements  #total elements
--------------------------------------------------
          Nodes:        13               13
          Edges:         6                6
      Subgraphs:         0                0
      Variables:        13               13
    Constraints:        20               20
</code></pre><h2 id="Partitioning-OptiGraphs"><a class="docs-heading-anchor" href="#Partitioning-OptiGraphs">Partitioning OptiGraphs</a><a id="Partitioning-OptiGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioning-OptiGraphs" title="Permalink"></a></h2><p>Plasmo.jl supports partitioning optigraphs wherein partitions of nodes and edges can be used to assemble optigraphs that contain subgraphs. This allows users to reveal and create nested optigraph structures that would be difficult (or impractical) to formulate otherwise. Plasmo.jl takes care of creating new optigraphs given partition information. </p><p>Since the <a href="../api_docs/#Plasmo.OptiGraph"><code>OptiGraph</code></a> is a <a href="https://en.wikipedia.org/wiki/Hypergraph">hypergraph</a> at its core, it naturally should  interface to various partitioning tools (both standard and hypergraph partitioning).  To begin however, we show how to partition an optigraph manually by defining vectors of node partitions. </p><p>We first define our manual partition as a vector of vectors. Each internal vector contains the  optinodes that correspond to a time interval. In this case, we assemble a vector of 5 time intervals. Using our vector we can construct a <a href="../api_docs/#Plasmo.Partition"><code>Partition</code></a> object which denotes node and edge partitions and how they are connected.</p><pre><code class="language-julia-repl hljs">julia&gt; all_graph_nodes = all_nodes(graph);

julia&gt; node_vectors = [[state[1:20];control[1:20]],[state[21:40];control[21:40]],[state[41:60];control[41:60]],[state[61:80];control[61:80]],[state[81:100];control[81:99]]];

julia&gt; manual_partition = Partition(graph, node_vectors)
OptiGraph Partition w/ 5 subpartitions
</code></pre><p>Once we construct a <a href="../api_docs/#Plasmo.Partition"><code>Partition</code></a>, we can assemble a new optigraph from the nodes using <a href="../api_docs/#Plasmo.assemble_optigraph"><code>assemble_optigraph</code></a>. Notice that the new graph contains few local elements (just the 4 edges that connect the new subgraphs).</p><pre><code class="language-julia-repl hljs">julia&gt; new_manual_graph = assemble_optigraph(manual_partition; name=:partitioned_graph)
An OptiGraph
partitioned_graph #local elements  #total elements
--------------------------------------------------
          Nodes:         0              199
          Edges:         4               99
      Subgraphs:         5                5
      Variables:         0              199
    Constraints:         4              299
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We can also modify an existing graph using <a href="../api_docs/#Plasmo.apply_partition!"><code>apply_partition!</code></a> versus creating a new graph. This can be useful for reducing memory requirements but it keep in mind it fundamentally alters the optigraph structure. Also note that this method is somewhat experimental; we suggest using <code>assemble_optigraph</code> if performance is not critical.</p></div></div><p>We now demonstrate how to use the hypergraph partitioning with <a href="https://github.com/kahypar/KaHyPar.jl">KaHyPar.jl</a> using the <a href="../api_docs/#Plasmo.hyper_projection"><code>hyper_projection</code></a> we created above. The general workflow is straightforward:</p><pre><code class="language-julia-repl hljs">julia&gt; using KaHyPar

julia&gt; using Suppressor # suppress KaHyPar output

julia&gt; partition_vector = @suppress KaHyPar.partition(projection, 8, configuration=:connectivity, imbalance=0.01);

julia&gt; partition_kahypar = Partition(projection, partition_vector)
OptiGraph Partition w/ 8 subpartitions

julia&gt; kahypar_graph = assemble_optigraph(partition_kahypar; name=:kahypar_graph)
An OptiGraph
   kahypar_graph #local elements  #total elements
--------------------------------------------------
          Nodes:         0              199
          Edges:         7               99
      Subgraphs:         8                8
      Variables:         0              199
    Constraints:         7              299
</code></pre><p>In this case, we ended up with a similar partition to the manual one (where instead we ask for 8 partitions as  KaHyPar makes it easy to do so). In most cases, the best partition is not this obvious.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>KaHyPar does not currently build on Windows. If you are interested in using graph partitioning with Plasmo.jl, read on to see how you can use <code>Metis</code>. </p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Plasmo.jl contains a direct interface to KaHyPar which is used here. In general, a  user can always construct the manual partition vector however they wish and generate  a <a href="../api_docs/#Plasmo.Partition"><code>Partition</code></a> object.</p></div></div><p>As a final example, we show how one might use Metis to partition this optigraph using the  <a href="../api_docs/#Plasmo.clique_projection"><code>clique_projection</code></a> presented earlier.</p><pre><code class="language-julia-repl hljs">julia&gt; using Metis

julia&gt; clique_proj
Graph Projection: Plasmo.CliqueGraphProjectionType()

julia&gt; simple_graph = clique_proj.projected_graph
{199, 297} undirected simple Int64 graph

julia&gt; metis_vector = Int64.(Metis.partition(simple_graph, 5)); # Plasmo.jl requires Int64 vectors.

julia&gt; partition_metis = Partition(clique_proj, metis_vector)
OptiGraph Partition w/ 5 subpartitions

julia&gt; metis_graph = assemble_optigraph(partition_metis; name=:metis_graph)
An OptiGraph
     metis_graph #local elements  #total elements
--------------------------------------------------
          Nodes:         0              199
          Edges:         4               99
      Subgraphs:         5                5
      Variables:         0              199
    Constraints:         4              299
</code></pre><p>If we plot and of the above partitioned optigraphs, it reveals five distinct partitions and the coupling between them. The plots show that the partitions are well-balanced and the matrix visualization shows the problem is reordered into a banded structure that is typical of dynamic optimization problems.</p><pre><code class="language-julia hljs">plt_chain_partition_layout = layout_plot(
    kahypar_graph,
     layout_options=Dict(
        :tol=&gt;0.01,
        :iterations=&gt;500
    ),
    linealpha=0.2,
    markersize=6,
    subgraph_colors=true
)
                                         )

plt_chain_partition_matrix = matrix_layout(kahypar_graph, subgraph_colors=true)
</code></pre><p><img src="../../assets/chain_layout_partition.svg" alt="partition_layout_2"/> <img src="../../assets/chain_layout_matrix_partition.svg" alt="partition_matrix_2"/></p><h2 id="Aggregating-OptiGraphs-(Experimental)"><a class="docs-heading-anchor" href="#Aggregating-OptiGraphs-(Experimental)">Aggregating OptiGraphs (Experimental)</a><a id="Aggregating-OptiGraphs-(Experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregating-OptiGraphs-(Experimental)" title="Permalink"></a></h2><p>Optigraphs can be converted into stand-alone optinodes using the using the <a href="../api_docs/#Plasmo.aggregate"><code>aggregate</code></a> and <a href="../api_docs/#Plasmo.aggregate_to_depth"><code>aggregate_to_depth</code></a> functions. This can be helpful when the user models using optigraphs, but they want to represent subproblems using optinodes. In the snippet below, we aggregate our optigraph that contains 5 subgraphs.  We include the argument <code>0</code> which specifies how many subgraph levels to retain.  In this case, <code>0</code> means we aggregate subgraphs at the highest level so <code>graph</code> contains only new aggregated optinodes. For hierarchical graphs with many levels, we can define how many subgraph levels we wish to retain. The function returns a new aggregated graph (<code>aggregate_graph</code>), as well as a <code>reference_map</code> which maps elements in <code>aggregate_graph</code> to the original optigraph <code>graph</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; aggregate_graph, reference_map = aggregate_to_depth(kahypar_graph, 0; name=:agg_graph);

julia&gt; aggregate_graph
An OptiGraph
       agg_graph #local elements  #total elements
--------------------------------------------------
          Nodes:         8                8
          Edges:         7                7
      Subgraphs:         0                0
      Variables:       199              199
    Constraints:       299              299
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A user can also use <code>aggregate!</code> to permanently aggregate an existing optigraph. This avoids maintaining a copy of the original optigraph.</p></div></div><p>We can lastly plot the aggregated graph structure which simply shows 8 optinodes with 7 linking constraints.</p><pre><code class="language-julia hljs">plt_chain_aggregate = layout_plot(
    aggregate_graph,
    layout_options=Dict(:tol=&gt;0.01,:iterations=&gt;10),
    node_labels=true,
    markersize=30,
    labelsize=20,
    node_colors=true
);

plt_chain_matrix_aggregate = matrix_plot(
    aggregate_graph,
    node_labels=true,
    node_colors=true
);
</code></pre><p><img src="../../assets/chain_layout_aggregate.svg" alt="partition_layout_3"/> <img src="../../assets/chain_layout_matrix_aggregate.svg" alt="partition_matrix_3"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modeling/">« Modeling with OptiGraphs</a><a class="docs-footer-nextpage" href="../api_docs/">API Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 2 October 2024 20:14">Wednesday 2 October 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
